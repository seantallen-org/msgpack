{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Packages msgpack","title":"msgpack"},{"location":"msgpack--index/","text":"Pony MessagePack \u00b6 Pure Pony package to support encoding to and decoding from the MessagePack serialization format. Usage \u00b6 Currently, the only API available is low-level encoding and decoding APIs. See MessagePackEncoder and MessagePackDecoder for more details. Public Types \u00b6 primitive MessagePackEncoder type MessagePackType primitive MessagePackDecoder actor Main","title":"Package"},{"location":"msgpack--index/#pony-messagepack","text":"Pure Pony package to support encoding to and decoding from the MessagePack serialization format.","title":"Pony MessagePack"},{"location":"msgpack--index/#usage","text":"Currently, the only API available is low-level encoding and decoding APIs. See MessagePackEncoder and MessagePackDecoder for more details.","title":"Usage"},{"location":"msgpack--index/#public-types","text":"primitive MessagePackEncoder type MessagePackType primitive MessagePackDecoder actor Main","title":"Public Types"},{"location":"msgpack-Main/","text":"Main \u00b6 [Source] actor tag Main is TestList ref Implements \u00b6 TestList ref Constructors \u00b6 create \u00b6 [Source] new tag create( env: Env val) : Main tag^ Parameters \u00b6 env: Env val Returns \u00b6 Main tag^ make \u00b6 [Source] new tag make() : Main tag^ Returns \u00b6 Main tag^ Public Functions \u00b6 tests \u00b6 [Source] fun tag tests( test: PonyTest tag) : None val Parameters \u00b6 test: PonyTest tag Returns \u00b6 None val runtime_override_defaults \u00b6 [Source] fun runtime_override_defaults( rto: RuntimeOptions ref) : None val Parameters \u00b6 rto: RuntimeOptions ref Returns \u00b6 None val","title":"actor Main"},{"location":"msgpack-Main/#main","text":"[Source] actor tag Main is TestList ref","title":"Main"},{"location":"msgpack-Main/#implements","text":"TestList ref","title":"Implements"},{"location":"msgpack-Main/#constructors","text":"","title":"Constructors"},{"location":"msgpack-Main/#create","text":"[Source] new tag create( env: Env val) : Main tag^","title":"create"},{"location":"msgpack-Main/#parameters","text":"env: Env val","title":"Parameters"},{"location":"msgpack-Main/#returns","text":"Main tag^","title":"Returns"},{"location":"msgpack-Main/#make","text":"[Source] new tag make() : Main tag^","title":"make"},{"location":"msgpack-Main/#returns_1","text":"Main tag^","title":"Returns"},{"location":"msgpack-Main/#public-functions","text":"","title":"Public Functions"},{"location":"msgpack-Main/#tests","text":"[Source] fun tag tests( test: PonyTest tag) : None val","title":"tests"},{"location":"msgpack-Main/#parameters_1","text":"test: PonyTest tag","title":"Parameters"},{"location":"msgpack-Main/#returns_2","text":"None val","title":"Returns"},{"location":"msgpack-Main/#runtime_override_defaults","text":"[Source] fun runtime_override_defaults( rto: RuntimeOptions ref) : None val","title":"runtime_override_defaults"},{"location":"msgpack-Main/#parameters_2","text":"rto: RuntimeOptions ref","title":"Parameters"},{"location":"msgpack-Main/#returns_3","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackDecoder/","text":"MessagePackDecoder \u00b6 [Source] Implements low-level decoding from the MessagePack serialization format . You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from incorrectly decoding documents. This is particularly true when using the array and map format family encoding methods. primitive val MessagePackDecoder Constructors \u00b6 create \u00b6 [Source] new val create() : MessagePackDecoder val^ Returns \u00b6 MessagePackDecoder val^ Public Functions \u00b6 nil \u00b6 [Source] Returns nothing. Throws an error if the next byte isn't a MessagePack nil. fun box nil( b: Reader ref) : None val ? Parameters \u00b6 b: Reader ref Returns \u00b6 None val ? bool \u00b6 [Source] fun box bool( b: Reader ref) : Bool val ? Parameters \u00b6 b: Reader ref Returns \u00b6 Bool val ? positive_fixint \u00b6 [Source] fun box positive_fixint( b: Reader ref) : U8 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U8 val ? negative_fixint \u00b6 [Source] fun box negative_fixint( b: Reader ref) : I8 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 I8 val ? u8 \u00b6 [Source] fun box u8( b: Reader ref) : U8 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U8 val ? u16 \u00b6 [Source] fun box u16( b: Reader ref) : U16 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U16 val ? u32 \u00b6 [Source] fun box u32( b: Reader ref) : U32 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U32 val ? u64 \u00b6 [Source] fun box u64( b: Reader ref) : U64 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U64 val ? i8 \u00b6 [Source] fun box i8( b: Reader ref) : I8 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 I8 val ? i16 \u00b6 [Source] fun box i16( b: Reader ref) : I16 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 I16 val ? i32 \u00b6 [Source] fun box i32( b: Reader ref) : I32 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 I32 val ? i64 \u00b6 [Source] fun box i64( b: Reader ref) : I64 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 I64 val ? f32 \u00b6 [Source] fun box f32( b: Reader ref) : F32 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 F32 val ? f64 \u00b6 [Source] fun box f64( b: Reader ref) : F64 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 F64 val ? fixstr \u00b6 [Source] fun box fixstr( b: Reader ref) : String iso^ ? Parameters \u00b6 b: Reader ref Returns \u00b6 String iso^ ? str \u00b6 [Source] fun box str( b: Reader ref) : String iso^ ? Parameters \u00b6 b: Reader ref Returns \u00b6 String iso^ ? byte_array \u00b6 [Source] fun box byte_array( b: Reader ref) : Array[U8 val] iso^ ? Parameters \u00b6 b: Reader ref Returns \u00b6 Array [ U8 val] iso^ ? fixarray \u00b6 [Source] Reads a header for a MessgePack \"fixarray\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. fun box fixarray( b: Reader ref) : U8 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U8 val ? array_16 \u00b6 [Source] Reads a header for a MessgePack \"array_16\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. fun box array_16( b: Reader ref) : U16 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U16 val ? array_32 \u00b6 [Source] Reads a header for a MessgePack \"array_32\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. fun box array_32( b: Reader ref) : U32 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U32 val ? fixmap \u00b6 [Source] Reads a header for a MessgePack \"fixmap\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. fun box fixmap( b: Reader ref) : U8 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U8 val ? map_16 \u00b6 [Source] Reads a header for a MessgePack \"map_16\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. fun box map_16( b: Reader ref) : U16 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U16 val ? map_32 \u00b6 [Source] Reads a header for a MessgePack \"map_32\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. fun box map_32( b: Reader ref) : U32 val ? Parameters \u00b6 b: Reader ref Returns \u00b6 U32 val ? ext \u00b6 [Source] Allows for the reading of user supplied extensions to the MessagePack format. fixext * types return a tuple representing: (user supplied type indentifier, data byte array) fun box ext( b: Reader ref) : (U8 val , Array[U8 val] val) ? Parameters \u00b6 b: Reader ref Returns \u00b6 ( U8 val , Array [ U8 val] val) ? timestamp \u00b6 [Source] fun box timestamp( b: Reader ref) : (I64 val , I64 val) ? Parameters \u00b6 b: Reader ref Returns \u00b6 ( I64 val , I64 val) ? eq \u00b6 [Source] fun box eq( that: MessagePackDecoder val) : Bool val Parameters \u00b6 that: MessagePackDecoder val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: MessagePackDecoder val) : Bool val Parameters \u00b6 that: MessagePackDecoder val Returns \u00b6 Bool val","title":"primitive MessagePackDecoder"},{"location":"msgpack-MessagePackDecoder/#messagepackdecoder","text":"[Source] Implements low-level decoding from the MessagePack serialization format . You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from incorrectly decoding documents. This is particularly true when using the array and map format family encoding methods. primitive val MessagePackDecoder","title":"MessagePackDecoder"},{"location":"msgpack-MessagePackDecoder/#constructors","text":"","title":"Constructors"},{"location":"msgpack-MessagePackDecoder/#create","text":"[Source] new val create() : MessagePackDecoder val^","title":"create"},{"location":"msgpack-MessagePackDecoder/#returns","text":"MessagePackDecoder val^","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#public-functions","text":"","title":"Public Functions"},{"location":"msgpack-MessagePackDecoder/#nil","text":"[Source] Returns nothing. Throws an error if the next byte isn't a MessagePack nil. fun box nil( b: Reader ref) : None val ?","title":"nil"},{"location":"msgpack-MessagePackDecoder/#parameters","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_1","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#bool","text":"[Source] fun box bool( b: Reader ref) : Bool val ?","title":"bool"},{"location":"msgpack-MessagePackDecoder/#parameters_1","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_2","text":"Bool val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#positive_fixint","text":"[Source] fun box positive_fixint( b: Reader ref) : U8 val ?","title":"positive_fixint"},{"location":"msgpack-MessagePackDecoder/#parameters_2","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_3","text":"U8 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#negative_fixint","text":"[Source] fun box negative_fixint( b: Reader ref) : I8 val ?","title":"negative_fixint"},{"location":"msgpack-MessagePackDecoder/#parameters_3","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_4","text":"I8 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#u8","text":"[Source] fun box u8( b: Reader ref) : U8 val ?","title":"u8"},{"location":"msgpack-MessagePackDecoder/#parameters_4","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_5","text":"U8 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#u16","text":"[Source] fun box u16( b: Reader ref) : U16 val ?","title":"u16"},{"location":"msgpack-MessagePackDecoder/#parameters_5","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_6","text":"U16 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#u32","text":"[Source] fun box u32( b: Reader ref) : U32 val ?","title":"u32"},{"location":"msgpack-MessagePackDecoder/#parameters_6","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_7","text":"U32 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#u64","text":"[Source] fun box u64( b: Reader ref) : U64 val ?","title":"u64"},{"location":"msgpack-MessagePackDecoder/#parameters_7","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_8","text":"U64 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#i8","text":"[Source] fun box i8( b: Reader ref) : I8 val ?","title":"i8"},{"location":"msgpack-MessagePackDecoder/#parameters_8","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_9","text":"I8 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#i16","text":"[Source] fun box i16( b: Reader ref) : I16 val ?","title":"i16"},{"location":"msgpack-MessagePackDecoder/#parameters_9","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_10","text":"I16 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#i32","text":"[Source] fun box i32( b: Reader ref) : I32 val ?","title":"i32"},{"location":"msgpack-MessagePackDecoder/#parameters_10","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_11","text":"I32 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#i64","text":"[Source] fun box i64( b: Reader ref) : I64 val ?","title":"i64"},{"location":"msgpack-MessagePackDecoder/#parameters_11","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_12","text":"I64 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#f32","text":"[Source] fun box f32( b: Reader ref) : F32 val ?","title":"f32"},{"location":"msgpack-MessagePackDecoder/#parameters_12","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_13","text":"F32 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#f64","text":"[Source] fun box f64( b: Reader ref) : F64 val ?","title":"f64"},{"location":"msgpack-MessagePackDecoder/#parameters_13","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_14","text":"F64 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#fixstr","text":"[Source] fun box fixstr( b: Reader ref) : String iso^ ?","title":"fixstr"},{"location":"msgpack-MessagePackDecoder/#parameters_14","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_15","text":"String iso^ ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#str","text":"[Source] fun box str( b: Reader ref) : String iso^ ?","title":"str"},{"location":"msgpack-MessagePackDecoder/#parameters_15","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_16","text":"String iso^ ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#byte_array","text":"[Source] fun box byte_array( b: Reader ref) : Array[U8 val] iso^ ?","title":"byte_array"},{"location":"msgpack-MessagePackDecoder/#parameters_16","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_17","text":"Array [ U8 val] iso^ ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#fixarray","text":"[Source] Reads a header for a MessgePack \"fixarray\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. fun box fixarray( b: Reader ref) : U8 val ?","title":"fixarray"},{"location":"msgpack-MessagePackDecoder/#parameters_17","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_18","text":"U8 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#array_16","text":"[Source] Reads a header for a MessgePack \"array_16\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. fun box array_16( b: Reader ref) : U16 val ?","title":"array_16"},{"location":"msgpack-MessagePackDecoder/#parameters_18","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_19","text":"U16 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#array_32","text":"[Source] Reads a header for a MessgePack \"array_32\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. fun box array_32( b: Reader ref) : U32 val ?","title":"array_32"},{"location":"msgpack-MessagePackDecoder/#parameters_19","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_20","text":"U32 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#fixmap","text":"[Source] Reads a header for a MessgePack \"fixmap\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. fun box fixmap( b: Reader ref) : U8 val ?","title":"fixmap"},{"location":"msgpack-MessagePackDecoder/#parameters_20","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_21","text":"U8 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#map_16","text":"[Source] Reads a header for a MessgePack \"map_16\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. fun box map_16( b: Reader ref) : U16 val ?","title":"map_16"},{"location":"msgpack-MessagePackDecoder/#parameters_21","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_22","text":"U16 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#map_32","text":"[Source] Reads a header for a MessgePack \"map_32\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. fun box map_32( b: Reader ref) : U32 val ?","title":"map_32"},{"location":"msgpack-MessagePackDecoder/#parameters_22","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_23","text":"U32 val ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#ext","text":"[Source] Allows for the reading of user supplied extensions to the MessagePack format. fixext * types return a tuple representing: (user supplied type indentifier, data byte array) fun box ext( b: Reader ref) : (U8 val , Array[U8 val] val) ?","title":"ext"},{"location":"msgpack-MessagePackDecoder/#parameters_23","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_24","text":"( U8 val , Array [ U8 val] val) ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#timestamp","text":"[Source] fun box timestamp( b: Reader ref) : (I64 val , I64 val) ?","title":"timestamp"},{"location":"msgpack-MessagePackDecoder/#parameters_24","text":"b: Reader ref","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_25","text":"( I64 val , I64 val) ?","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#eq","text":"[Source] fun box eq( that: MessagePackDecoder val) : Bool val","title":"eq"},{"location":"msgpack-MessagePackDecoder/#parameters_25","text":"that: MessagePackDecoder val","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_26","text":"Bool val","title":"Returns"},{"location":"msgpack-MessagePackDecoder/#ne","text":"[Source] fun box ne( that: MessagePackDecoder val) : Bool val","title":"ne"},{"location":"msgpack-MessagePackDecoder/#parameters_26","text":"that: MessagePackDecoder val","title":"Parameters"},{"location":"msgpack-MessagePackDecoder/#returns_27","text":"Bool val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/","text":"MessagePackEncoder \u00b6 [Source] Implements low-level encoding into the MessagePack serialization format . You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from creating invalid documents. This is particularly true when using the array and map format family encoding methods. primitive val MessagePackEncoder Constructors \u00b6 create \u00b6 [Source] new val create() : MessagePackEncoder val^ Returns \u00b6 MessagePackEncoder val^ Public Functions \u00b6 nil \u00b6 [Source] nil format stores nil in 1 byte. fun box nil( b: Writer ref) : None val Parameters \u00b6 b: Writer ref Returns \u00b6 None val bool \u00b6 [Source] bool format family stores false or true in 1 byte. fun box bool( b: Writer ref, t_or_f: Bool val) : None val Parameters \u00b6 b: Writer ref t_or_f: Bool val Returns \u00b6 None val positive_fixint \u00b6 [Source] positive fixnum stores 7-bit positive integer. Max value that can be encoded is 127 . Attemping to encode an out of range value will result in an error . fun box positive_fixint( b: Writer ref, v: U8 val) : None val ? Parameters \u00b6 b: Writer ref v: U8 val Returns \u00b6 None val ? negative_fixint \u00b6 [Source] negative fixnum stores 5-bit negative integer. Max value that can be encoded is -1 . Min value that can be encoded is -32 . Attemping to encode an out of range value will result in an error . fun box negative_fixint( b: Writer ref, v: I8 val) : None val ? Parameters \u00b6 b: Writer ref v: I8 val Returns \u00b6 None val ? uint_8 \u00b6 [Source] uint 8 stores a 8-bit unsigned integer. fun box uint_8( b: Writer ref, v: U8 val) : None val Parameters \u00b6 b: Writer ref v: U8 val Returns \u00b6 None val uint_16 \u00b6 [Source] uint 16 stores a 16-bit big-endian unsigned integer. fun box uint_16( b: Writer ref, v: U16 val) : None val Parameters \u00b6 b: Writer ref v: U16 val Returns \u00b6 None val uint_32 \u00b6 [Source] uint 32 stores a 32-bit big-endian unsigned integer. fun box uint_32( b: Writer ref, v: U32 val) : None val Parameters \u00b6 b: Writer ref v: U32 val Returns \u00b6 None val uint_64 \u00b6 [Source] uint 64 stores a 64-bit big-endian unsigned integer. fun box uint_64( b: Writer ref, v: U64 val) : None val Parameters \u00b6 b: Writer ref v: U64 val Returns \u00b6 None val int_8 \u00b6 [Source] int 8 stores a 8-bit signed integer. fun box int_8( b: Writer ref, v: I8 val) : None val Parameters \u00b6 b: Writer ref v: I8 val Returns \u00b6 None val int_16 \u00b6 [Source] int 16 stores a 16-bit big-endian signed integer. fun box int_16( b: Writer ref, v: I16 val) : None val Parameters \u00b6 b: Writer ref v: I16 val Returns \u00b6 None val int_32 \u00b6 [Source] int 32 stores a 32-bit big-endian signed integer. fun box int_32( b: Writer ref, v: I32 val) : None val Parameters \u00b6 b: Writer ref v: I32 val Returns \u00b6 None val int_64 \u00b6 [Source] int 64 stores a 64-bit big-endian signed integer. fun box int_64( b: Writer ref, v: I64 val) : None val Parameters \u00b6 b: Writer ref v: I64 val Returns \u00b6 None val float_32 \u00b6 [Source] float 32 stores a floating point number in IEEE 754 single precision floating point number format. fun box float_32( b: Writer ref, v: F32 val) : None val Parameters \u00b6 b: Writer ref v: F32 val Returns \u00b6 None val float_64 \u00b6 [Source] float 64 stores a floating point number in IEEE 754 double precision floating point number format. fun box float_64( b: Writer ref, v: F64 val) : None val Parameters \u00b6 b: Writer ref v: F64 val Returns \u00b6 None val fixstr \u00b6 [Source] fixstr stores a byte array whose length is upto 31 bytes. Attempting to encode a ByteSeq larger than 31 bytes will result in an error . fun box fixstr( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? str_8 \u00b6 [Source] str 8 stores a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a ByteSeq larger than (2^8)-1 bytes will result in an error . fun box str_8( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? str_16 \u00b6 [Source] str 16 stores a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a ByteSeq larger than (2^16)-1 bytes will result in an error . fun box str_16( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? str_32 \u00b6 [Source] str 32 stores a byte array whose length is upto (2^32)-1. Attempting to encode a ByteSeq larger than (2^32)-1 bytes will result in an error . fun box str_32( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? bin_8 \u00b6 [Source] bin 8 stores a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a ByteSeq larger than (2^8)-1 bytes will result in an error . fun box bin_8( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? bin_16 \u00b6 [Source] bin 16 stores a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a ByteSeq larger than (2^16)-1 bytes will result in an error . fun box bin_16( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? bin_32 \u00b6 [Source] bin 32 stores a byte array whose length is upto (2^32)-1 bytes. Attempting to encode a ByteSeq larger than (2^32)-1 bytes will result in an error . fun box bin_32( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? fixarray \u00b6 [Source] Creates a header for a MessagePack \"fixarray\". This only creates the header. s number of array items should be written via other methods after this is called. fixarray stores an array whose length is upto 15 elements. Attempting to encode a value larger than 15 will result in an error . fun box fixarray( b: Writer ref, s: U8 val) : None val ? Parameters \u00b6 b: Writer ref s: U8 val Returns \u00b6 None val ? array_16 \u00b6 [Source] Creates a header for a MessagePack \"array_16\". This only creates the header. s number of array items should be written via other methods after this is called. array 16 stores an array whose length is upto (2^16)-1 elements. Attempting to encode a value larger than (2^16)-1 bytes will result in an error . fun box array_16( b: Writer ref, s: U16 val) : None val Parameters \u00b6 b: Writer ref s: U16 val Returns \u00b6 None val array_32 \u00b6 [Source] Creates a header for a MessagePack \"array_32\". This only creates the header. s number of array items should be written via other methods after this is called. array 32 stores an array whose length is upto (2^32)-1 elements. Attempting to encode a value larger than (2^32)-1 bytes will result in an error . fun box array_32( b: Writer ref, s: U32 val) : None val Parameters \u00b6 b: Writer ref s: U32 val Returns \u00b6 None val fixmap \u00b6 [Source] Creates a header for a MessagePack \"fixmap\". This only creates the header. s number of map items should be written via other methods after this is called. fixmap stores a map whose length is upto 15 elements. Attempting to encode a value larger than 15 will result in an error . fun box fixmap( b: Writer ref, s: U8 val) : None val ? Parameters \u00b6 b: Writer ref s: U8 val Returns \u00b6 None val ? map_16 \u00b6 [Source] Creates a header for a MessagePack \"map_16\". This only creates the header. s number of map items should be written via other methods after this is called. map 16 stores an array whose length is upto (2^16)-1 elements. Attempting to encode a value larger than (2^16)-1 bytes will result in an error . fun box map_16( b: Writer ref, s: U16 val) : None val Parameters \u00b6 b: Writer ref s: U16 val Returns \u00b6 None val map_32 \u00b6 [Source] Creates a header for a MessagePack \"map_32\". This only creates the header. s number of map items should be written via other methods after this is called. map 32 stores an array whose length is upto (2^32)-1 elements. Attempting to encode a value larger than (2^32)-1 bytes will result in an error . fun box map_32( b: Writer ref, s: U32 val) : None val Parameters \u00b6 b: Writer ref s: U32 val Returns \u00b6 None val fixext_1 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 1 stores an integer and a byte array whose length is 1 byte. Attempting to encode a ByteSeq that is not 1 element in size will result in an error . fun box fixext_1( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? fixext_2 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 2 stores an integer and a byte array whose length is 2 byte. Attempting to encode a ByteSeq that is not 2 element in size will result in an error . fun box fixext_2( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? fixext_4 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 4 stores an integer and a byte array whose length is 4 byte. Attempting to encode a ByteSeq that is not 4 element in size will result in an error . fun box fixext_4( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? fixext_8 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 8 stores an integer and a byte array whose length is 8 byte. Attempting to encode a ByteSeq that is not 8 element in size will result in an error . fun box fixext_8( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? fixext_16 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 16 stores an integer and a byte array whose length is 16 byte. Attempting to encode a ByteSeq that is not 16 element in size will result in an error . fun box fixext_16( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? ext_8 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a ByteSeq that is larger than (2^8)-1 bytes in size will result in an error . fun box ext_8( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? ext_16 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a ByteSeq that is larger than (2^16)-1 bytes in size will result in an error . fun box ext_16( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? ext_32 \u00b6 [Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes. Attempting to encode a ByteSeq that is larger than (2^32)-1 bytes in size will result in an error . fun box ext_32( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? timestamp_32 \u00b6 [Source] timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in a 32-bit unsigned integer. It can represent a timestamp in [1970-01-01 00:00:00 UTC, 2106-02-07 06:28:16 UTC). Nanoseconds part is 0. fun box timestamp_32( b: Writer ref, sec: U32 val) : None val Parameters \u00b6 b: Writer ref sec: U32 val Returns \u00b6 None val timestamp_64 \u00b6 [Source] timestamp 64 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers. It can represent a timestamp in [1970-01-01 00:00:00.000000000 UTC, 2514-05-30 01:53:04.000000000 UTC). nsec must not be larger than 999999999. sec must not be larger than (2^34 - 1). fun box timestamp_64( b: Writer ref, sec: U64 val, nsec: U32 val) : None val ? Parameters \u00b6 b: Writer ref sec: U64 val nsec: U32 val Returns \u00b6 None val ? timestamp_96 \u00b6 [Source] timestamp 96 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer. It can represent a timestamp in [-584554047284-02-23 16:59:44 UTC, 584554051223-11-09 07:00:16.000000000 UTC). nsec must not be larger than 999999999. fun box timestamp_96( b: Writer ref, sec: I64 val, nsec: U32 val) : None val ? Parameters \u00b6 b: Writer ref sec: I64 val nsec: U32 val Returns \u00b6 None val ? eq \u00b6 [Source] fun box eq( that: MessagePackEncoder val) : Bool val Parameters \u00b6 that: MessagePackEncoder val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: MessagePackEncoder val) : Bool val Parameters \u00b6 that: MessagePackEncoder val Returns \u00b6 Bool val","title":"primitive MessagePackEncoder"},{"location":"msgpack-MessagePackEncoder/#messagepackencoder","text":"[Source] Implements low-level encoding into the MessagePack serialization format . You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from creating invalid documents. This is particularly true when using the array and map format family encoding methods. primitive val MessagePackEncoder","title":"MessagePackEncoder"},{"location":"msgpack-MessagePackEncoder/#constructors","text":"","title":"Constructors"},{"location":"msgpack-MessagePackEncoder/#create","text":"[Source] new val create() : MessagePackEncoder val^","title":"create"},{"location":"msgpack-MessagePackEncoder/#returns","text":"MessagePackEncoder val^","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#public-functions","text":"","title":"Public Functions"},{"location":"msgpack-MessagePackEncoder/#nil","text":"[Source] nil format stores nil in 1 byte. fun box nil( b: Writer ref) : None val","title":"nil"},{"location":"msgpack-MessagePackEncoder/#parameters","text":"b: Writer ref","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_1","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#bool","text":"[Source] bool format family stores false or true in 1 byte. fun box bool( b: Writer ref, t_or_f: Bool val) : None val","title":"bool"},{"location":"msgpack-MessagePackEncoder/#parameters_1","text":"b: Writer ref t_or_f: Bool val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_2","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#positive_fixint","text":"[Source] positive fixnum stores 7-bit positive integer. Max value that can be encoded is 127 . Attemping to encode an out of range value will result in an error . fun box positive_fixint( b: Writer ref, v: U8 val) : None val ?","title":"positive_fixint"},{"location":"msgpack-MessagePackEncoder/#parameters_2","text":"b: Writer ref v: U8 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_3","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#negative_fixint","text":"[Source] negative fixnum stores 5-bit negative integer. Max value that can be encoded is -1 . Min value that can be encoded is -32 . Attemping to encode an out of range value will result in an error . fun box negative_fixint( b: Writer ref, v: I8 val) : None val ?","title":"negative_fixint"},{"location":"msgpack-MessagePackEncoder/#parameters_3","text":"b: Writer ref v: I8 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_4","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#uint_8","text":"[Source] uint 8 stores a 8-bit unsigned integer. fun box uint_8( b: Writer ref, v: U8 val) : None val","title":"uint_8"},{"location":"msgpack-MessagePackEncoder/#parameters_4","text":"b: Writer ref v: U8 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_5","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#uint_16","text":"[Source] uint 16 stores a 16-bit big-endian unsigned integer. fun box uint_16( b: Writer ref, v: U16 val) : None val","title":"uint_16"},{"location":"msgpack-MessagePackEncoder/#parameters_5","text":"b: Writer ref v: U16 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_6","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#uint_32","text":"[Source] uint 32 stores a 32-bit big-endian unsigned integer. fun box uint_32( b: Writer ref, v: U32 val) : None val","title":"uint_32"},{"location":"msgpack-MessagePackEncoder/#parameters_6","text":"b: Writer ref v: U32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_7","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#uint_64","text":"[Source] uint 64 stores a 64-bit big-endian unsigned integer. fun box uint_64( b: Writer ref, v: U64 val) : None val","title":"uint_64"},{"location":"msgpack-MessagePackEncoder/#parameters_7","text":"b: Writer ref v: U64 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_8","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#int_8","text":"[Source] int 8 stores a 8-bit signed integer. fun box int_8( b: Writer ref, v: I8 val) : None val","title":"int_8"},{"location":"msgpack-MessagePackEncoder/#parameters_8","text":"b: Writer ref v: I8 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_9","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#int_16","text":"[Source] int 16 stores a 16-bit big-endian signed integer. fun box int_16( b: Writer ref, v: I16 val) : None val","title":"int_16"},{"location":"msgpack-MessagePackEncoder/#parameters_9","text":"b: Writer ref v: I16 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_10","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#int_32","text":"[Source] int 32 stores a 32-bit big-endian signed integer. fun box int_32( b: Writer ref, v: I32 val) : None val","title":"int_32"},{"location":"msgpack-MessagePackEncoder/#parameters_10","text":"b: Writer ref v: I32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_11","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#int_64","text":"[Source] int 64 stores a 64-bit big-endian signed integer. fun box int_64( b: Writer ref, v: I64 val) : None val","title":"int_64"},{"location":"msgpack-MessagePackEncoder/#parameters_11","text":"b: Writer ref v: I64 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_12","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#float_32","text":"[Source] float 32 stores a floating point number in IEEE 754 single precision floating point number format. fun box float_32( b: Writer ref, v: F32 val) : None val","title":"float_32"},{"location":"msgpack-MessagePackEncoder/#parameters_12","text":"b: Writer ref v: F32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_13","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#float_64","text":"[Source] float 64 stores a floating point number in IEEE 754 double precision floating point number format. fun box float_64( b: Writer ref, v: F64 val) : None val","title":"float_64"},{"location":"msgpack-MessagePackEncoder/#parameters_13","text":"b: Writer ref v: F64 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_14","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixstr","text":"[Source] fixstr stores a byte array whose length is upto 31 bytes. Attempting to encode a ByteSeq larger than 31 bytes will result in an error . fun box fixstr( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"fixstr"},{"location":"msgpack-MessagePackEncoder/#parameters_14","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_15","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#str_8","text":"[Source] str 8 stores a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a ByteSeq larger than (2^8)-1 bytes will result in an error . fun box str_8( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"str_8"},{"location":"msgpack-MessagePackEncoder/#parameters_15","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_16","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#str_16","text":"[Source] str 16 stores a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a ByteSeq larger than (2^16)-1 bytes will result in an error . fun box str_16( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"str_16"},{"location":"msgpack-MessagePackEncoder/#parameters_16","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_17","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#str_32","text":"[Source] str 32 stores a byte array whose length is upto (2^32)-1. Attempting to encode a ByteSeq larger than (2^32)-1 bytes will result in an error . fun box str_32( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"str_32"},{"location":"msgpack-MessagePackEncoder/#parameters_17","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_18","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#bin_8","text":"[Source] bin 8 stores a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a ByteSeq larger than (2^8)-1 bytes will result in an error . fun box bin_8( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"bin_8"},{"location":"msgpack-MessagePackEncoder/#parameters_18","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_19","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#bin_16","text":"[Source] bin 16 stores a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a ByteSeq larger than (2^16)-1 bytes will result in an error . fun box bin_16( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"bin_16"},{"location":"msgpack-MessagePackEncoder/#parameters_19","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_20","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#bin_32","text":"[Source] bin 32 stores a byte array whose length is upto (2^32)-1 bytes. Attempting to encode a ByteSeq larger than (2^32)-1 bytes will result in an error . fun box bin_32( b: Writer ref, v: (String val | Array[U8 val] val)) : None val ?","title":"bin_32"},{"location":"msgpack-MessagePackEncoder/#parameters_20","text":"b: Writer ref v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_21","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixarray","text":"[Source] Creates a header for a MessagePack \"fixarray\". This only creates the header. s number of array items should be written via other methods after this is called. fixarray stores an array whose length is upto 15 elements. Attempting to encode a value larger than 15 will result in an error . fun box fixarray( b: Writer ref, s: U8 val) : None val ?","title":"fixarray"},{"location":"msgpack-MessagePackEncoder/#parameters_21","text":"b: Writer ref s: U8 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_22","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#array_16","text":"[Source] Creates a header for a MessagePack \"array_16\". This only creates the header. s number of array items should be written via other methods after this is called. array 16 stores an array whose length is upto (2^16)-1 elements. Attempting to encode a value larger than (2^16)-1 bytes will result in an error . fun box array_16( b: Writer ref, s: U16 val) : None val","title":"array_16"},{"location":"msgpack-MessagePackEncoder/#parameters_22","text":"b: Writer ref s: U16 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_23","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#array_32","text":"[Source] Creates a header for a MessagePack \"array_32\". This only creates the header. s number of array items should be written via other methods after this is called. array 32 stores an array whose length is upto (2^32)-1 elements. Attempting to encode a value larger than (2^32)-1 bytes will result in an error . fun box array_32( b: Writer ref, s: U32 val) : None val","title":"array_32"},{"location":"msgpack-MessagePackEncoder/#parameters_23","text":"b: Writer ref s: U32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_24","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixmap","text":"[Source] Creates a header for a MessagePack \"fixmap\". This only creates the header. s number of map items should be written via other methods after this is called. fixmap stores a map whose length is upto 15 elements. Attempting to encode a value larger than 15 will result in an error . fun box fixmap( b: Writer ref, s: U8 val) : None val ?","title":"fixmap"},{"location":"msgpack-MessagePackEncoder/#parameters_24","text":"b: Writer ref s: U8 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_25","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#map_16","text":"[Source] Creates a header for a MessagePack \"map_16\". This only creates the header. s number of map items should be written via other methods after this is called. map 16 stores an array whose length is upto (2^16)-1 elements. Attempting to encode a value larger than (2^16)-1 bytes will result in an error . fun box map_16( b: Writer ref, s: U16 val) : None val","title":"map_16"},{"location":"msgpack-MessagePackEncoder/#parameters_25","text":"b: Writer ref s: U16 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_26","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#map_32","text":"[Source] Creates a header for a MessagePack \"map_32\". This only creates the header. s number of map items should be written via other methods after this is called. map 32 stores an array whose length is upto (2^32)-1 elements. Attempting to encode a value larger than (2^32)-1 bytes will result in an error . fun box map_32( b: Writer ref, s: U32 val) : None val","title":"map_32"},{"location":"msgpack-MessagePackEncoder/#parameters_26","text":"b: Writer ref s: U32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_27","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixext_1","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 1 stores an integer and a byte array whose length is 1 byte. Attempting to encode a ByteSeq that is not 1 element in size will result in an error . fun box fixext_1( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"fixext_1"},{"location":"msgpack-MessagePackEncoder/#parameters_27","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_28","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixext_2","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 2 stores an integer and a byte array whose length is 2 byte. Attempting to encode a ByteSeq that is not 2 element in size will result in an error . fun box fixext_2( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"fixext_2"},{"location":"msgpack-MessagePackEncoder/#parameters_28","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_29","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixext_4","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 4 stores an integer and a byte array whose length is 4 byte. Attempting to encode a ByteSeq that is not 4 element in size will result in an error . fun box fixext_4( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"fixext_4"},{"location":"msgpack-MessagePackEncoder/#parameters_29","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_30","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixext_8","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 8 stores an integer and a byte array whose length is 8 byte. Attempting to encode a ByteSeq that is not 8 element in size will result in an error . fun box fixext_8( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"fixext_8"},{"location":"msgpack-MessagePackEncoder/#parameters_30","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_31","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#fixext_16","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 16 stores an integer and a byte array whose length is 16 byte. Attempting to encode a ByteSeq that is not 16 element in size will result in an error . fun box fixext_16( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"fixext_16"},{"location":"msgpack-MessagePackEncoder/#parameters_31","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_32","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#ext_8","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a ByteSeq that is larger than (2^8)-1 bytes in size will result in an error . fun box ext_8( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"ext_8"},{"location":"msgpack-MessagePackEncoder/#parameters_32","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_33","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#ext_16","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a ByteSeq that is larger than (2^16)-1 bytes in size will result in an error . fun box ext_16( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"ext_16"},{"location":"msgpack-MessagePackEncoder/#parameters_33","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_34","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#ext_32","text":"[Source] Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value v to be encoded, but a unique type identifier t as well. Type identifiers 0 to 127 are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes. Attempting to encode a ByteSeq that is larger than (2^32)-1 bytes in size will result in an error . fun box ext_32( b: Writer ref, t: U8 val, v: (String val | Array[U8 val] val)) : None val ?","title":"ext_32"},{"location":"msgpack-MessagePackEncoder/#parameters_34","text":"b: Writer ref t: U8 val v: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_35","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#timestamp_32","text":"[Source] timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in a 32-bit unsigned integer. It can represent a timestamp in [1970-01-01 00:00:00 UTC, 2106-02-07 06:28:16 UTC). Nanoseconds part is 0. fun box timestamp_32( b: Writer ref, sec: U32 val) : None val","title":"timestamp_32"},{"location":"msgpack-MessagePackEncoder/#parameters_35","text":"b: Writer ref sec: U32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_36","text":"None val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#timestamp_64","text":"[Source] timestamp 64 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers. It can represent a timestamp in [1970-01-01 00:00:00.000000000 UTC, 2514-05-30 01:53:04.000000000 UTC). nsec must not be larger than 999999999. sec must not be larger than (2^34 - 1). fun box timestamp_64( b: Writer ref, sec: U64 val, nsec: U32 val) : None val ?","title":"timestamp_64"},{"location":"msgpack-MessagePackEncoder/#parameters_36","text":"b: Writer ref sec: U64 val nsec: U32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_37","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#timestamp_96","text":"[Source] timestamp 96 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer. It can represent a timestamp in [-584554047284-02-23 16:59:44 UTC, 584554051223-11-09 07:00:16.000000000 UTC). nsec must not be larger than 999999999. fun box timestamp_96( b: Writer ref, sec: I64 val, nsec: U32 val) : None val ?","title":"timestamp_96"},{"location":"msgpack-MessagePackEncoder/#parameters_37","text":"b: Writer ref sec: I64 val nsec: U32 val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_38","text":"None val ?","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#eq","text":"[Source] fun box eq( that: MessagePackEncoder val) : Bool val","title":"eq"},{"location":"msgpack-MessagePackEncoder/#parameters_38","text":"that: MessagePackEncoder val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_39","text":"Bool val","title":"Returns"},{"location":"msgpack-MessagePackEncoder/#ne","text":"[Source] fun box ne( that: MessagePackEncoder val) : Bool val","title":"ne"},{"location":"msgpack-MessagePackEncoder/#parameters_39","text":"that: MessagePackEncoder val","title":"Parameters"},{"location":"msgpack-MessagePackEncoder/#returns_40","text":"Bool val","title":"Returns"},{"location":"msgpack-MessagePackType/","text":"MessagePackType \u00b6 [Source] type MessagePackType is U8 val Type Alias For \u00b6 U8 val","title":"type MessagePackType"},{"location":"msgpack-MessagePackType/#messagepacktype","text":"[Source] type MessagePackType is U8 val","title":"MessagePackType"},{"location":"msgpack-MessagePackType/#type-alias-for","text":"U8 val","title":"Type Alias For"},{"location":"src/msgpack/_test/","text":"/* Copyright 2017 The Pony MessagePack Developers Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ use \"pony_test\" actor Main is TestList new create(env: Env) => PonyTest(env, this) new make() => None fun tag tests(test: PonyTest) => _TestDecoder.make().tests(test) _TestEncoder.make().tests(test)","title":" test"},{"location":"src/msgpack/message_pack_decoder/","text":"/* Copyright 2017 The Pony MessagePack Developers Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ use \"buffered\" type MessagePackType is U8 primitive MessagePackDecoder \"\"\" Implements low-level decoding from the [MessagePack serialization format](https://github.com/msgpack/msgpack/blob/master/spec.md). You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from incorrectly decoding documents. This is particularly true when using the `array` and `map` format family encoding methods. \"\"\" // // nil format family // fun nil(b: Reader ref): None ? => \"\"\" Returns nothing. Throws an error if the next byte isn't a MessagePack nil. \"\"\" if _read_type(b)? != _FormatName.nil() then error end // // bool format family // fun bool(b: Reader ref): Bool ? => match _read_type(b)? | _FormatName.truthy() => true | _FormatName.falsey() => false else error end // // fixed number family // fun positive_fixint(b: Reader ref): U8 ? => b.u8()? fun negative_fixint(b: Reader ref): I8 ? => b.i8()? // // unsigned int family // fun u8(b: Reader ref): U8 ? => if _read_type(b)? != _FormatName.uint_8() then error end b.u8()? fun u16(b: Reader ref): U16 ? => if _read_type(b)? != _FormatName.uint_16() then error end b.u16_be()? fun u32(b: Reader ref): U32 ? => if _read_type(b)? != _FormatName.uint_32() then error end b.u32_be()? fun u64(b: Reader ref): U64 ? => if _read_type(b)? != _FormatName.uint_64() then error end b.u64_be()? // // signed integer family // fun i8(b: Reader ref): I8 ? => if _read_type(b)? != _FormatName.int_8() then error end b.i8()? fun i16(b: Reader ref): I16 ? => if _read_type(b)? != _FormatName.int_16() then error end b.i16_be()? fun i32(b: Reader ref): I32 ? => if _read_type(b)? != _FormatName.int_32() then error end b.i32_be()? fun i64(b: Reader ref): I64 ? => if _read_type(b)? != _FormatName.int_64() then error end b.i64_be()? // // float format family // fun f32(b: Reader ref): F32 ? => if _read_type(b)? != _FormatName.float_32() then error end b.f32_be()? fun f64(b: Reader ref): F64 ? => if _read_type(b)? != _FormatName.float_64() then error end b.f64_be()? // // str family // fun fixstr(b: Reader): String iso^ ? => let len = (b.u8()?.usize() and _Limit.fixstr()) String.from_iso_array(b.block(len)?) fun str(b: Reader): String iso^ ? => let t = _read_type(b)? let len = if t == _FormatName.str_8() then b.u8()? elseif t == _FormatName.str_16() then b.u16_be()?.usize() elseif t == _FormatName.str_32() then b.u32_be()?.usize() else error end String.from_iso_array(b.block(len.usize())?) // // byte array family // fun byte_array(b: Reader): Array[U8] iso^ ? => let t = _read_type(b)? let len = if t == _FormatName.bin_8() then b.u8()? elseif t == _FormatName.bin_16() then b.u16_be()?.usize() elseif t == _FormatName.bin_32() then b.u32_be()?.usize() else error end b.block(len.usize())? // // array format family // fun fixarray(b: Reader): U8 ? => \"\"\" Reads a header for a MessgePack \"fixarray\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. \"\"\" (b.u8()? and _Limit.fixarray()) fun array_16(b: Reader): U16 ? => \"\"\" Reads a header for a MessgePack \"array_16\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. \"\"\" if _read_type(b)? != _FormatName.array_16() then error end b.u16_be()? fun array_32(b: Reader): U32 ? => \"\"\" Reads a header for a MessgePack \"array_32\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called. \"\"\" if _read_type(b)? != _FormatName.array_32() then error end b.u32_be()? // // map format family // fun fixmap(b: Reader): U8 ? => \"\"\" Reads a header for a MessgePack \"fixmap\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. \"\"\" (b.u8()? and _Limit.fixmap()) fun map_16(b: Reader): U16 ? => \"\"\" Reads a header for a MessgePack \"map_16\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. \"\"\" if _read_type(b)? != _FormatName.map_16() then error end b.u16_be()? fun map_32(b: Reader): U32 ? => \"\"\" Reads a header for a MessgePack \"map_32\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called. \"\"\" if _read_type(b)? != _FormatName.map_32() then error end b.u32_be()? // // ext format family // fun ext(b: Reader): (U8, Array[U8] val) ? => \"\"\" Allows for the reading of user supplied extensions to the MessagePack format. fixext * types return a tuple representing: (user supplied type indentifier, data byte array) \"\"\" let t = _read_type(b)? let size: USize = if t == _FormatName.fixext_1() then 1 elseif t == _FormatName.fixext_2() then 2 elseif t == _FormatName.fixext_4() then 4 elseif t == _FormatName.fixext_8() then 8 elseif t == _FormatName.fixext_16() then 16 elseif t == _FormatName.ext_8() then b.u8()?.usize() elseif t == _FormatName.ext_16() then b.u16_be()?.usize() elseif t == _FormatName.ext_32() then b.u32_be()?.usize() else error end (b.u8()?, b.block(size)?) // // timestamp format family // fun timestamp(b: Reader): (I64, I64) ? => let t = _read_type(b)? b.i8()? var nsec: I64 = 0 var sec: I64 = 0 if t == _FormatName.fixext_4() then sec = b.u32_be()?.i64() elseif t == _FormatName.fixext_8() then let u: U64 = b.u64_be()? nsec = (u >> 34).i64() sec = (u - (nsec.u64() << 34)).i64() elseif t == _FormatName.ext_8() then b.u8()? nsec = b.u32_be()?.i64() sec = b.i64_be()? else error end (sec, nsec) // // support functions // fun _read_type(b: Reader ref): MessagePackType ? => b.u8()?","title":"Message pack decoder"},{"location":"src/msgpack/message_pack_encoder/","text":"/* Copyright 2017 The Pony MessagePack Developers Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ use \"buffered\" primitive MessagePackEncoder \"\"\" Implements low-level encoding into the [MessagePack serialization format](https://github.com/msgpack/msgpack/blob/master/spec.md). You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from creating invalid documents. This is particularly true when using the `array` and `map` format family encoding methods. \"\"\" // // nil format family // fun nil(b: Writer) => \"\"\" nil format stores nil in 1 byte. \"\"\" _write_type(b, _FormatName.nil()) // // bool format family // fun bool(b: Writer, t_or_f: Bool) => \"\"\" bool format family stores false or true in 1 byte. \"\"\" if t_or_f then _write_type(b, _FormatName.truthy()) else _write_type(b, _FormatName.falsey()) end // // int format family // fun positive_fixint(b: Writer, v: U8) ? => \"\"\" positive fixnum stores 7-bit positive integer. - Max value that can be encoded is `127`. Attemping to encode an out of range value will result in an `error`. \"\"\" if v <= _Limit.positive_fixint() then _write_fixed_value(b, v) else error end fun negative_fixint(b: Writer, v: I8) ? => \"\"\" negative fixnum stores 5-bit negative integer. - Max value that can be encoded is `-1`. - Min value that can be encoded is `-32`. Attemping to encode an out of range value will result in an `error`. \"\"\" if (v >= _Limit.negative_fixint_low()) and (v <= _Limit.negative_fixint_high()) then _write_fixed_value(b, v.u8()) else error end fun uint_8(b: Writer, v: U8) => \"\"\" uint 8 stores a 8-bit unsigned integer. \"\"\" _write_type(b, _FormatName.uint_8()) b.u8(v) fun uint_16(b: Writer, v: U16) => \"\"\" uint 16 stores a 16-bit big-endian unsigned integer. \"\"\" _write_type(b, _FormatName.uint_16()) b.u16_be(v) fun uint_32(b: Writer, v: U32) => \"\"\" uint 32 stores a 32-bit big-endian unsigned integer. \"\"\" _write_type(b, _FormatName.uint_32()) b.u32_be(v) fun uint_64(b: Writer, v: U64) => \"\"\" uint 64 stores a 64-bit big-endian unsigned integer. \"\"\" _write_type(b, _FormatName.uint_64()) b.u64_be(v) fun int_8(b: Writer, v: I8) => \"\"\" int 8 stores a 8-bit signed integer. \"\"\" _write_type(b, _FormatName.int_8()) b.u8(v.u8()) fun int_16(b: Writer, v: I16) => \"\"\" int 16 stores a 16-bit big-endian signed integer. \"\"\" _write_type(b, _FormatName.int_16()) b.i16_be(v) fun int_32(b: Writer, v: I32) => \"\"\" int 32 stores a 32-bit big-endian signed integer. \"\"\" _write_type(b, _FormatName.int_32()) b.i32_be(v) fun int_64(b: Writer, v: I64) => \"\"\" int 64 stores a 64-bit big-endian signed integer. \"\"\" _write_type(b, _FormatName.int_64()) b.i64_be(v) // // float format family // fun float_32(b: Writer, v: F32) => \"\"\" float 32 stores a floating point number in IEEE 754 single precision floating point number format. \"\"\" _write_type(b, _FormatName.float_32()) b.f32_be(v) fun float_64(b: Writer, v: F64) => \"\"\" float 64 stores a floating point number in IEEE 754 double precision floating point number format. \"\"\" _write_type(b, _FormatName.float_64()) b.f64_be(v) // // str format family // fun fixstr(b: Writer, v: ByteSeq) ? => \"\"\" fixstr stores a byte array whose length is upto 31 bytes. Attempting to encode a `ByteSeq` larger than 31 bytes will result in an `error`. \"\"\" if v.size() <= _Limit.fixstr() then _write_type(b, (_FormatName.fixstr() or v.size().u8())) b.write(v) else error end fun str_8(b: Writer, v: ByteSeq) ? => \"\"\" str 8 stores a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a `ByteSeq` larger than (2^8)-1 bytes will result in an `error`. \"\"\" _write_byte_array_8(b, v, _FormatName.str_8())? fun str_16(b: Writer, v: ByteSeq) ? => \"\"\" str 16 stores a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a `ByteSeq` larger than (2^16)-1 bytes will result in an `error`. \"\"\" _write_byte_array_16(b, v, _FormatName.str_16())? fun str_32(b: Writer, v: ByteSeq) ? => \"\"\" str 32 stores a byte array whose length is upto (2^32)-1. Attempting to encode a `ByteSeq` larger than (2^32)-1 bytes will result in an `error`. \"\"\" _write_byte_array_32(b, v, _FormatName.str_32())? // // bin format family // fun bin_8(b: Writer, v: ByteSeq) ? => \"\"\" bin 8 stores a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a `ByteSeq` larger than (2^8)-1 bytes will result in an `error`. \"\"\" _write_byte_array_8(b, v, _FormatName.bin_8())? fun bin_16(b: Writer, v: ByteSeq) ? => \"\"\" bin 16 stores a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a `ByteSeq` larger than (2^16)-1 bytes will result in an `error`. \"\"\" _write_byte_array_16(b, v, _FormatName.bin_16())? fun bin_32(b: Writer, v: ByteSeq) ? => \"\"\" bin 32 stores a byte array whose length is upto (2^32)-1 bytes. Attempting to encode a `ByteSeq` larger than (2^32)-1 bytes will result in an `error`. \"\"\" _write_byte_array_32(b, v, _FormatName.bin_32())? // // array format family // fun fixarray(b: Writer, s: U8) ? => \"\"\" Creates a header for a MessagePack \"fixarray\". This only creates the header. `s` number of array items should be written via other methods after this is called. fixarray stores an array whose length is upto 15 elements. Attempting to encode a value larger than 15 will result in an `error`. \"\"\" if s <= _Limit.fixarray() then _write_type(b, (_FormatName.fixarray() or s)) else error end fun array_16(b: Writer, s: U16) => \"\"\" Creates a header for a MessagePack \"array_16\". This only creates the header. `s` number of array items should be written via other methods after this is called. array 16 stores an array whose length is upto (2^16)-1 elements. Attempting to encode a value larger than (2^16)-1 bytes will result in an `error`. \"\"\" _write_type(b, _FormatName.array_16()) b.u16_be(s) fun array_32(b: Writer, s: U32) => \"\"\" Creates a header for a MessagePack \"array_32\". This only creates the header. `s` number of array items should be written via other methods after this is called. array 32 stores an array whose length is upto (2^32)-1 elements. Attempting to encode a value larger than (2^32)-1 bytes will result in an `error`. \"\"\" _write_type(b, _FormatName.array_32()) b.u32_be(s) // // map format family // fun fixmap(b: Writer, s: U8) ? => \"\"\" Creates a header for a MessagePack \"fixmap\". This only creates the header. `s` number of map items should be written via other methods after this is called. fixmap stores a map whose length is upto 15 elements. Attempting to encode a value larger than 15 will result in an `error`. \"\"\" if s <= _Limit.fixmap() then _write_type(b, (_FormatName.fixmap() or s)) else error end fun map_16(b: Writer, s: U16) => \"\"\" Creates a header for a MessagePack \"map_16\". This only creates the header. `s` number of map items should be written via other methods after this is called. map 16 stores an array whose length is upto (2^16)-1 elements. Attempting to encode a value larger than (2^16)-1 bytes will result in an `error`. \"\"\" _write_type(b, _FormatName.map_16()) b.u16_be(s) fun map_32(b: Writer, s: U32) => \"\"\" Creates a header for a MessagePack \"map_32\". This only creates the header. `s` number of map items should be written via other methods after this is called. map 32 stores an array whose length is upto (2^32)-1 elements. Attempting to encode a value larger than (2^32)-1 bytes will result in an `error`. \"\"\" _write_type(b, _FormatName.map_32()) b.u32_be(s) // // ext format family // fun fixext_1(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 1 stores an integer and a byte array whose length is 1 byte. Attempting to encode a `ByteSeq` that is not 1 element in size will result in an `error`. \"\"\" if v.size() == _Size.fixext_1() then _write_type(b, _FormatName.fixext_1()) b.u8(t) b.write(v) else error end fun fixext_2(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 2 stores an integer and a byte array whose length is 2 byte. Attempting to encode a `ByteSeq` that is not 2 element in size will result in an `error`. \"\"\" if v.size() == _Size.fixext_2() then _write_type(b, _FormatName.fixext_2()) b.u8(t) b.write(v) else error end fun fixext_4(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 4 stores an integer and a byte array whose length is 4 byte. Attempting to encode a `ByteSeq` that is not 4 element in size will result in an `error`. \"\"\" if v.size() == _Size.fixext_4() then _write_type(b, _FormatName.fixext_4()) b.u8(t) b.write(v) else error end fun fixext_8(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 8 stores an integer and a byte array whose length is 8 byte. Attempting to encode a `ByteSeq` that is not 8 element in size will result in an `error`. \"\"\" if v.size() == _Size.fixext_8() then _write_type(b, _FormatName.fixext_8()) b.u8(t) b.write(v) else error end fun fixext_16(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. fixext 16 stores an integer and a byte array whose length is 16 byte. Attempting to encode a `ByteSeq` that is not 16 element in size will result in an `error`. \"\"\" if v.size() == _Size.fixext_16() then _write_type(b, _FormatName.fixext_16()) b.u8(t) b.write(v) else error end fun ext_8(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes. Attempting to encode a `ByteSeq` that is larger than (2^8)-1 bytes in size will result in an `error`. \"\"\" if v.size() <= U8.max_value().usize() then _write_type(b, _FormatName.ext_8()) b.u8(v.size().u8()) b.u8(t) b.write(v) else error end fun ext_16(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes. Attempting to encode a `ByteSeq` that is larger than (2^16)-1 bytes in size will result in an `error`. \"\"\" if v.size() <= U16.max_value().usize() then _write_type(b, _FormatName.ext_16()) b.u16_be(v.size().u16()) b.u8(t) b.write(v) else error end fun ext_32(b: Writer, t: U8, v: ByteSeq) ? => \"\"\" Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value `v` to be encoded, but a unique type identifier `t` as well. Type identifiers `0` to `127` are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types. ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes. Attempting to encode a `ByteSeq` that is larger than (2^32)-1 bytes in size will result in an `error`. \"\"\" if v.size() <= U32.max_value().usize() then _write_type(b, _FormatName.ext_32()) b.u32_be(v.size().u32()) b.u8(t) b.write(v) else error end // // timestamp format family // fun timestamp_32(b: Writer, sec: U32) => \"\"\" timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in a 32-bit unsigned integer. It can represent a timestamp in [1970-01-01 00:00:00 UTC, 2106-02-07 06:28:16 UTC). Nanoseconds part is 0. \"\"\" _write_type(b, _FormatName.fixext_4()) b.u8(-1) b.u32_be(sec) fun timestamp_64(b: Writer, sec: U64, nsec: U32) ? => \"\"\" timestamp 64 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers. It can represent a timestamp in [1970-01-01 00:00:00.000000000 UTC, 2514-05-30 01:53:04.000000000 UTC). `nsec` must not be larger than 999999999. `sec` must not be larger than (2^34 - 1). \"\"\" if (nsec <= _Limit.nsec()) and (sec <= _Limit.sec_34()) then _write_type(b, _FormatName.fixext_8()) b.u8(-1) b.u64_be((nsec.u64() << 34) + sec) else error end fun timestamp_96(b: Writer, sec: I64, nsec: U32) ? => \"\"\" timestamp 96 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer. It can represent a timestamp in [-584554047284-02-23 16:59:44 UTC, 584554051223-11-09 07:00:16.000000000 UTC). `nsec` must not be larger than 999999999. \"\"\" if nsec <= _Limit.nsec() then _write_type(b, _FormatName.ext_8()) b.u8(12) b.u8(-1) b.u32_be(nsec) b.i64_be(sec) else error end // // support methods // fun _write_type(b: Writer, t: U8) => b.u8(t) fun _write_fixed_value(b: Writer, v: U8) => b.u8(v) fun _write_byte_array_8(b: Writer, v: ByteSeq, t: U8) ? => if v.size() <= U8.max_value().usize() then _write_type(b, t) b.u8(v.size().u8()) b.write(v) else error end fun _write_byte_array_16(b: Writer, v: ByteSeq, t: U8) ? => if v.size() <= U16.max_value().usize() then _write_type(b, t) b.u16_be(v.size().u16()) b.write(v) else error end fun _write_byte_array_32(b: Writer, v: ByteSeq, t: U8) ? => if v.size() <= U32.max_value().usize() then _write_type(b, t) b.u32_be(v.size().u32()) b.write(v) else error end","title":"Message pack encoder"}]}