{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"msgpack--index/","title":"Pony MessagePack","text":"<p>Pure Pony implementation of the MessagePack serialization format.</p> <p>Three public APIs are available:</p> <ul> <li> <p><code>MessagePackEncoder</code> \u2014 Stateless encoding methods. Compact methods   (<code>uint</code>, <code>int</code>, <code>str</code>, <code>bin</code>, <code>array</code>, <code>map</code>, <code>ext</code>, <code>timestamp</code>)   automatically select the smallest wire format. Format-specific methods   (<code>uint_8</code>, <code>uint_32</code>, <code>fixstr</code>, <code>str_8</code>, etc.) are available for   explicit control.</p> </li> <li> <p><code>MessagePackDecoder</code> \u2014 Stateless decoding methods. Compact methods   (<code>uint</code>, <code>int</code>, <code>str</code>, <code>array</code>, <code>map</code>) accept any wire format within a   format family. Format-specific methods are available when the caller   knows the exact wire format. Assumes all data is available; not suitable   for streaming.</p> </li> <li> <p><code>MessagePackStreamingDecoder</code> \u2014 A streaming-safe decoder that peeks before   consuming bytes. Returns <code>NotEnoughData</code> when more bytes are needed, with   zero bytes consumed.</p> </li> </ul>"},{"location":"msgpack--index/#encoding-and-decoding-scalar-values","title":"Encoding and Decoding Scalar Values","text":"<p>Compact methods pick the smallest wire format automatically:</p> <pre><code>use \"buffered\"\nuse \"msgpack\"\n\n// Encode\nlet w: Writer ref = Writer\nMessagePackEncoder.nil(w)\nMessagePackEncoder.bool(w, true)\nMessagePackEncoder.uint(w, 42)       // positive_fixint (1 byte)\nMessagePackEncoder.str(w, \"hello\")?  // fixstr (6 bytes)\n\n// Transfer encoded bytes to a reader\nlet r: Reader ref = Reader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\n// Decode \u2014 compact methods accept any format in the family\nMessagePackDecoder.nil(r)?\nlet b = MessagePackDecoder.bool(r)?\nlet n = MessagePackDecoder.uint(r)?\nlet s = MessagePackDecoder.str(r)?\n</code></pre> <p>Format-specific methods (<code>uint_32</code>, <code>fixstr</code>, <code>str_8</code>, etc.) are available when you need explicit control over the wire format.</p>"},{"location":"msgpack--index/#encoding-and-decoding-arrays","title":"Encoding and Decoding Arrays","text":"<p>Array and map methods only write or read headers containing the element count. The caller must encode or decode each element individually.</p> <pre><code>// Encode a 3-element array of U32\nlet w: Writer ref = Writer\nMessagePackEncoder.array(w, 3)  // picks fixarray\nMessagePackEncoder.uint(w, 1)\nMessagePackEncoder.uint(w, 2)\nMessagePackEncoder.uint(w, 3)\n\n// Decode\nlet r: Reader ref = Reader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\nlet count = MessagePackDecoder.array(r)?\nvar i: U32 = 0\nwhile i &lt; count do\n  let v = MessagePackDecoder.uint(r)?\n  // use v\n  i = i + 1\nend\n</code></pre>"},{"location":"msgpack--index/#encoding-and-decoding-maps","title":"Encoding and Decoding Maps","text":"<p>Map entries are key-value pairs. The header specifies the number of pairs. Keys and values are encoded alternately.</p> <pre><code>// Encode a 2-entry map: \"a\" =&gt; 1, \"b\" =&gt; 2\nlet w: Writer ref = Writer\nMessagePackEncoder.map(w, 2)       // picks fixmap\nMessagePackEncoder.str(w, \"a\")?\nMessagePackEncoder.uint(w, 1)\nMessagePackEncoder.str(w, \"b\")?\nMessagePackEncoder.uint(w, 2)\n\n// Decode\nlet r: Reader ref = Reader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\nlet count = MessagePackDecoder.map(r)?\nvar i: U32 = 0\nwhile i &lt; count do\n  let key = MessagePackDecoder.str(r)?\n  let value = MessagePackDecoder.uint(r)?\n  // use key and value\n  i = i + 1\nend\n</code></pre>"},{"location":"msgpack--index/#streaming-decoder","title":"Streaming Decoder","text":"<p><code>MessagePackStreamingDecoder</code> is safe for incremental data. It returns <code>MessagePackArray</code> or <code>MessagePackMap</code> header objects for containers; the caller then reads the elements.</p> <pre><code>let sd = MessagePackStreamingDecoder\nsd.append(data)\n\nmatch sd.next()\n| None =&gt; None // decoded nil\n| let v: U32 =&gt; None // decoded a U32\n| let a: MessagePackArray =&gt;\n  // read a.size elements\n  var i: U32 = 0\n  while i &lt; a.size do\n    match sd.next()\n    | let v: U32 =&gt; None // use v\n    end\n    i = i + 1\n  end\n| let m: MessagePackMap =&gt;\n  // read m.size key-value pairs\n  var i: U32 = 0\n  while i &lt; m.size do\n    match sd.next()\n    | let key: String val =&gt; None\n    end\n    match sd.next()\n    | let value: U32 =&gt; None\n    end\n    i = i + 1\n  end\n| NotEnoughData =&gt; None // need more bytes\n| InvalidData =&gt; None // stream is corrupt\nend\n</code></pre>"},{"location":"msgpack--index/#public-types","title":"Public Types","text":"<ul> <li>type DecodeResult</li> <li>primitive InvalidData</li> <li>class MessagePackArray</li> <li>primitive MessagePackDecoder</li> <li>primitive MessagePackEncoder</li> <li>class MessagePackExt</li> <li>class MessagePackMap</li> <li>class MessagePackStreamingDecoder</li> <li>class MessagePackTimestamp</li> <li>type MessagePackType</li> <li>type MessagePackValue</li> <li>primitive NotEnoughData</li> </ul>"},{"location":"msgpack-DecodeResult/","title":"DecodeResult","text":"<p>[Source] <pre><code>type DecodeResult is\n  (None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val | NotEnoughData val | InvalidData val)\n</code></pre></p>"},{"location":"msgpack-DecodeResult/#type-alias-for","title":"Type Alias For","text":"<ul> <li>(None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val | NotEnoughData val | InvalidData val)</li> </ul>"},{"location":"msgpack-InvalidData/","title":"InvalidData","text":"<p>[Source]</p> <p>Returned when the data contains an invalid MessagePack format byte. The stream is corrupt and decoding should stop.</p> <pre><code>primitive val InvalidData\n</code></pre>"},{"location":"msgpack-InvalidData/#constructors","title":"Constructors","text":""},{"location":"msgpack-InvalidData/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: InvalidData val^\n</code></pre>"},{"location":"msgpack-InvalidData/#returns","title":"Returns","text":"<ul> <li>InvalidData val^</li> </ul>"},{"location":"msgpack-InvalidData/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-InvalidData/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: InvalidData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-InvalidData/#parameters","title":"Parameters","text":"<ul> <li>that: InvalidData val</li> </ul>"},{"location":"msgpack-InvalidData/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-InvalidData/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: InvalidData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-InvalidData/#parameters_1","title":"Parameters","text":"<ul> <li>that: InvalidData val</li> </ul>"},{"location":"msgpack-InvalidData/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackArray/","title":"MessagePackArray","text":"<p>[Source]</p> <p>Header for a MessagePack array. The <code>size</code> field indicates how many elements follow. The caller is responsible for reading <code>size</code> subsequent values.</p> <pre><code>class val MessagePackArray\n</code></pre>"},{"location":"msgpack-MessagePackArray/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackArray/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  size': U32 val)\n: MessagePackArray val^\n</code></pre>"},{"location":"msgpack-MessagePackArray/#parameters","title":"Parameters","text":"<ul> <li>size': U32 val</li> </ul>"},{"location":"msgpack-MessagePackArray/#returns","title":"Returns","text":"<ul> <li>MessagePackArray val^</li> </ul>"},{"location":"msgpack-MessagePackArray/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackArray/#let-size-u32-val","title":"let size: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecoder/","title":"MessagePackDecoder","text":"<p>[Source]</p> <p>Implements low-level decoding from the MessagePack serialization format.</p> <p>You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from incorrectly decoding documents. This is particularly true when using the <code>array</code> and <code>map</code> format family decoding methods, which only read headers \u2014 the caller must read each element individually afterward.</p> <p>Two styles of decode methods are provided:</p> <ul> <li>Compact methods (<code>uint</code>, <code>int</code>, <code>str</code>, <code>byte_array</code>, <code>ext</code>,   <code>array</code>, <code>map</code>) peek at the format byte to determine the wire   format and accept any format within the family.</li> <li>Format-specific methods (<code>u8</code>, <code>u16</code>, <code>str_8</code>, <code>str_16</code>,   <code>bin_8</code>, <code>fixext_1</code>, <code>ext_8</code>, etc.) validate a single expected   format byte, then read the data directly. Use these when you   know the exact wire format in advance.</li> </ul> <p>This decoder assumes all data is available when decoding begins. If data may arrive incrementally, use <code>MessagePackStreamingDecoder</code> instead.</p> <pre><code>primitive val MessagePackDecoder\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackDecoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: MessagePackDecoder val^\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#returns","title":"Returns","text":"<ul> <li>MessagePackDecoder val^</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackDecoder/#uint","title":"uint","text":"<p>[Source]</p> <p>Decodes an unsigned integer from any uint or positive fixint format.</p> <pre><code>fun box uint(\n  b: Reader ref)\n: U64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_1","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#int","title":"int","text":"<p>[Source]</p> <p>Decodes a signed integer from any int, uint, or fixint format. Errors if a uint_64 value exceeds I64.max_value().</p> <pre><code>fun box int(\n  b: Reader ref)\n: I64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_1","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_2","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#array","title":"array","text":"<p>[Source]</p> <p>Reads an array header from any array format. Returns the element count. The caller must read that many elements afterward.</p> <pre><code>fun box array(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_2","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_3","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#map","title":"map","text":"<p>[Source]</p> <p>Reads a map header from any map format. Returns the pair count. The caller must read that many key-value pairs afterward.</p> <pre><code>fun box map(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_3","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_4","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#nil","title":"nil","text":"<p>[Source]</p> <p>Returns nothing. Throws an error if the next byte isn't a MessagePack nil.</p> <pre><code>fun box nil(\n  b: Reader ref)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_4","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_5","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bool","title":"bool","text":"<p>[Source]</p> <pre><code>fun box bool(\n  b: Reader ref)\n: Bool val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_5","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_6","title":"Returns","text":"<ul> <li>Bool val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#positive_fixint","title":"positive_fixint","text":"<p>[Source]</p> <pre><code>fun box positive_fixint(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_6","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_7","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#negative_fixint","title":"negative_fixint","text":"<p>[Source]</p> <pre><code>fun box negative_fixint(\n  b: Reader ref)\n: I8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_7","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_8","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u8","title":"u8","text":"<p>[Source]</p> <pre><code>fun box u8(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_8","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_9","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u16","title":"u16","text":"<p>[Source]</p> <pre><code>fun box u16(\n  b: Reader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_9","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_10","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u32","title":"u32","text":"<p>[Source]</p> <pre><code>fun box u32(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_10","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_11","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u64","title":"u64","text":"<p>[Source]</p> <pre><code>fun box u64(\n  b: Reader ref)\n: U64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_11","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_12","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i8","title":"i8","text":"<p>[Source]</p> <pre><code>fun box i8(\n  b: Reader ref)\n: I8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_12","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_13","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i16","title":"i16","text":"<p>[Source]</p> <pre><code>fun box i16(\n  b: Reader ref)\n: I16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_13","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_14","title":"Returns","text":"<ul> <li>I16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i32","title":"i32","text":"<p>[Source]</p> <pre><code>fun box i32(\n  b: Reader ref)\n: I32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_14","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_15","title":"Returns","text":"<ul> <li>I32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i64","title":"i64","text":"<p>[Source]</p> <pre><code>fun box i64(\n  b: Reader ref)\n: I64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_15","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_16","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#f32","title":"f32","text":"<p>[Source]</p> <pre><code>fun box f32(\n  b: Reader ref)\n: F32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_16","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_17","title":"Returns","text":"<ul> <li>F32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#f64","title":"f64","text":"<p>[Source]</p> <pre><code>fun box f64(\n  b: Reader ref)\n: F64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_17","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_18","title":"Returns","text":"<ul> <li>F64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixstr","title":"fixstr","text":"<p>[Source]</p> <pre><code>fun box fixstr(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_18","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_19","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str","title":"str","text":"<p>[Source]</p> <pre><code>fun box str(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_19","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_20","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_8","title":"str_8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 8 value. Validates that the format byte is str_8 (0xD9), then reads the 1-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_20","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_21","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_16","title":"str_16","text":"<p>[Source]</p> <p>Decodes a MessagePack str 16 value. Validates that the format byte is str_16 (0xDA), then reads the 2-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_16(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_21","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_22","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_32","title":"str_32","text":"<p>[Source]</p> <p>Decodes a MessagePack str 32 value. Validates that the format byte is str_32 (0xDB), then reads the 4-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_32(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_22","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_23","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#byte_array","title":"byte_array","text":"<p>[Source]</p> <pre><code>fun box byte_array(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_23","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_24","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bin_8","title":"bin_8","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 8 value. Validates that the format byte is bin_8 (0xC4), then reads the 1-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_8(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_24","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_25","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bin_16","title":"bin_16","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 16 value. Validates that the format byte is bin_16 (0xC5), then reads the 2-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_16(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_25","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_26","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bin_32","title":"bin_32","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 32 value. Validates that the format byte is bin_32 (0xC6), then reads the 4-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_32(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_26","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_27","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixarray","title":"fixarray","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"fixarray\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box fixarray(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_27","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_28","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#array_16","title":"array_16","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"array_16\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box array_16(\n  b: Reader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_28","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_29","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#array_32","title":"array_32","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"array_32\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box array_32(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_29","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_30","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixmap","title":"fixmap","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"fixmap\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box fixmap(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_30","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_31","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#map_16","title":"map_16","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"map_16\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box map_16(\n  b: Reader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_31","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_32","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#map_32","title":"map_32","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"map_32\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box map_32(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_32","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_33","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext","title":"ext","text":"<p>[Source]</p> <p>Allows for the reading of user supplied extensions to the MessagePack format.</p> <p>fixext * types return a tuple representing:</p> <p>(user supplied type indentifier, data byte array)</p> <pre><code>fun box ext(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_33","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_34","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_1","title":"fixext_1","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 1 value. Validates that the format byte is fixext_1 (0xD4), then reads the ext type byte and 1 byte of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_1(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_34","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_35","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_2","title":"fixext_2","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 2 value. Validates that the format byte is fixext_2 (0xD5), then reads the ext type byte and 2 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_2(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_35","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_36","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_4","title":"fixext_4","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 4 value. Validates that the format byte is fixext_4 (0xD6), then reads the ext type byte and 4 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_4(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_36","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_37","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_8","title":"fixext_8","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 8 value. Validates that the format byte is fixext_8 (0xD7), then reads the ext type byte and 8 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_8(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_37","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_38","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_16","title":"fixext_16","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 16 value. Validates that the format byte is fixext_16 (0xD8), then reads the ext type byte and 16 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_16(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_38","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_39","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext_8","title":"ext_8","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 8 value. Validates that the format byte is ext_8 (0xC7), then reads the 1-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_8(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_39","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_40","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext_16","title":"ext_16","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 16 value. Validates that the format byte is ext_16 (0xC8), then reads the 2-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_16(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_40","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_41","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext_32","title":"ext_32","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 32 value. Validates that the format byte is ext_32 (0xC9), then reads the 4-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_32(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_41","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_42","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#timestamp","title":"timestamp","text":"<p>[Source]</p> <pre><code>fun box timestamp(\n  b: Reader ref)\n: (I64 val , U32 val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_42","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_43","title":"Returns","text":"<ul> <li>(I64 val , U32 val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: MessagePackDecoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_43","title":"Parameters","text":"<ul> <li>that: MessagePackDecoder val</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_44","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: MessagePackDecoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_44","title":"Parameters","text":"<ul> <li>that: MessagePackDecoder val</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_45","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/","title":"MessagePackEncoder","text":"<p>[Source]</p> <p>Implements low-level encoding into the MessagePack serialization format.</p> <p>You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from creating invalid documents. This is particularly true when using the <code>array</code> and <code>map</code> format family encoding methods, which only write headers \u2014 the caller must write each element individually afterward.</p> <p>For decoding, see <code>MessagePackDecoder</code> (all-at-once) or <code>MessagePackStreamingDecoder</code> (incremental/streaming).</p> <pre><code>primitive val MessagePackEncoder\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackEncoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: MessagePackEncoder val^\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#returns","title":"Returns","text":"<ul> <li>MessagePackEncoder val^</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackEncoder/#uint","title":"uint","text":"<p>[Source]</p> <p>Encodes an unsigned integer using the smallest format that fits the value.</p> <pre><code>fun box uint(\n  b: Writer ref,\n  v: U64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_1","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int","title":"int","text":"<p>[Source]</p> <p>Encodes a signed integer using the smallest format that fits the value. Positive values use unsigned formats when smaller, per the MessagePack spec (all int/uint formats are one family).</p> <pre><code>fun box int(\n  b: Writer ref,\n  v: I64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_1","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_2","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str","title":"str","text":"<p>[Source]</p> <p>Encodes a string using the smallest format that fits the byte length.</p> <pre><code>fun box str(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_2","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_3","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin","title":"bin","text":"<p>[Source]</p> <p>Encodes a binary byte array using the smallest format that fits the byte length.</p> <pre><code>fun box bin(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_3","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_4","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#array","title":"array","text":"<p>[Source]</p> <p>Creates an array header using the smallest format that fits the element count. The caller must write <code>s</code> elements after this call.</p> <pre><code>fun box array(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_4","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_5","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#map","title":"map","text":"<p>[Source]</p> <p>Creates a map header using the smallest format that fits the pair count. The caller must write <code>s</code> key-value pairs after this call.</p> <pre><code>fun box map(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_5","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_6","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext","title":"ext","text":"<p>[Source]</p> <p>Encodes an extension value using the smallest format that fits the data length. Prefers fixext formats for sizes 1, 2, 4, 8, and 16.</p> <pre><code>fun box ext(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_6","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_7","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp","title":"timestamp","text":"<p>[Source]</p> <p>Encodes a timestamp using the smallest format that fits the value. Uses timestamp_32 when nanoseconds are zero and seconds fit in a U32, timestamp_64 when seconds fit in 34 bits, and timestamp_96 otherwise.</p> <pre><code>fun box timestamp(\n  b: Writer ref,\n  sec: I64 val,\n  nsec: U32 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_7","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: I64 val</li> <li>nsec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_8","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#nil","title":"nil","text":"<p>[Source]</p> <p>nil format stores nil in 1 byte.</p> <pre><code>fun box nil(\n  b: Writer ref)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_8","title":"Parameters","text":"<ul> <li>b: Writer ref</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_9","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bool","title":"bool","text":"<p>[Source]</p> <p>bool format family stores false or true in 1 byte.</p> <pre><code>fun box bool(\n  b: Writer ref,\n  t_or_f: Bool val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_9","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t_or_f: Bool val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_10","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#positive_fixint","title":"positive_fixint","text":"<p>[Source]</p> <p>positive fixnum stores 7-bit positive integer.</p> <ul> <li>Max value that can be encoded is <code>127</code>.</li> </ul> <p>Attemping to encode an out of range value will result in an <code>error</code>.</p> <pre><code>fun box positive_fixint(\n  b: Writer ref,\n  v: U8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_10","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_11","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#negative_fixint","title":"negative_fixint","text":"<p>[Source]</p> <p>negative fixnum stores 5-bit negative integer.</p> <ul> <li>Max value that can be encoded is <code>-1</code>.</li> <li>Min value that can be encoded is <code>-32</code>.</li> </ul> <p>Attemping to encode an out of range value will result in an <code>error</code>.</p> <pre><code>fun box negative_fixint(\n  b: Writer ref,\n  v: I8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_11","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_12","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_8","title":"uint_8","text":"<p>[Source]</p> <p>uint 8 stores a 8-bit unsigned integer.</p> <pre><code>fun box uint_8(\n  b: Writer ref,\n  v: U8 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_12","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_13","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_16","title":"uint_16","text":"<p>[Source]</p> <p>uint 16 stores a 16-bit big-endian unsigned integer.</p> <pre><code>fun box uint_16(\n  b: Writer ref,\n  v: U16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_13","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_14","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_32","title":"uint_32","text":"<p>[Source]</p> <p>uint 32 stores a 32-bit big-endian unsigned integer.</p> <pre><code>fun box uint_32(\n  b: Writer ref,\n  v: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_14","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_15","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_64","title":"uint_64","text":"<p>[Source]</p> <p>uint 64 stores a 64-bit big-endian unsigned integer.</p> <pre><code>fun box uint_64(\n  b: Writer ref,\n  v: U64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_15","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_16","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_8","title":"int_8","text":"<p>[Source]</p> <p>int 8 stores a 8-bit signed integer.</p> <pre><code>fun box int_8(\n  b: Writer ref,\n  v: I8 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_16","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_17","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_16","title":"int_16","text":"<p>[Source]</p> <p>int 16 stores a 16-bit big-endian signed integer.</p> <pre><code>fun box int_16(\n  b: Writer ref,\n  v: I16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_17","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_18","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_32","title":"int_32","text":"<p>[Source]</p> <p>int 32 stores a 32-bit big-endian signed integer.</p> <pre><code>fun box int_32(\n  b: Writer ref,\n  v: I32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_18","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_19","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_64","title":"int_64","text":"<p>[Source]</p> <p>int 64 stores a 64-bit big-endian signed integer.</p> <pre><code>fun box int_64(\n  b: Writer ref,\n  v: I64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_19","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_20","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#float_32","title":"float_32","text":"<p>[Source]</p> <p>float 32 stores a floating point number in IEEE 754 single precision floating point number format.</p> <pre><code>fun box float_32(\n  b: Writer ref,\n  v: F32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_20","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: F32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_21","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#float_64","title":"float_64","text":"<p>[Source]</p> <p>float 64 stores a floating point number in IEEE 754 double precision floating point number format.</p> <pre><code>fun box float_64(\n  b: Writer ref,\n  v: F64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_21","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: F64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_22","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixstr","title":"fixstr","text":"<p>[Source]</p> <p>fixstr stores a byte array whose length is upto 31 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than 31 bytes will result in an <code>error</code>.</p> <pre><code>fun box fixstr(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_22","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_23","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_8","title":"str_8","text":"<p>[Source]</p> <p>str 8 stores a byte array whose length is upto (2^8)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^8)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box str_8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_23","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_24","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_16","title":"str_16","text":"<p>[Source]</p> <p>str 16 stores a byte array whose length is upto (2^16)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box str_16(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_24","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_25","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_32","title":"str_32","text":"<p>[Source]</p> <p>str 32 stores a byte array whose length is upto (2^32)-1.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box str_32(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_25","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_26","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin_8","title":"bin_8","text":"<p>[Source]</p> <p>bin 8 stores a byte array whose length is upto (2^8)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^8)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box bin_8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_26","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_27","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin_16","title":"bin_16","text":"<p>[Source]</p> <p>bin 16 stores a byte array whose length is upto (2^16)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box bin_16(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_27","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_28","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin_32","title":"bin_32","text":"<p>[Source]</p> <p>bin 32 stores a byte array whose length is upto (2^32)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box bin_32(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_28","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_29","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixarray","title":"fixarray","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"fixarray\". This only creates the header. <code>s</code> number of array items should be written via other methods after this is called.</p> <p>fixarray stores an array whose length is upto 15 elements.</p> <p>Attempting to encode a value larger than 15 will result in an <code>error</code>.</p> <pre><code>fun box fixarray(\n  b: Writer ref,\n  s: U8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_29","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_30","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#array_16","title":"array_16","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"array_16\". This only creates the header. <code>s</code> number of array items should be written via other methods after this is called.</p> <p>array 16 stores an array whose length is upto (2^16)-1 elements.</p> <p>Attempting to encode a value larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box array_16(\n  b: Writer ref,\n  s: U16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_30","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_31","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#array_32","title":"array_32","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"array_32\". This only creates the header. <code>s</code> number of array items should be written via other methods after this is called.</p> <p>array 32 stores an array whose length is upto (2^32)-1 elements.</p> <p>Attempting to encode a value larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box array_32(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_31","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_32","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixmap","title":"fixmap","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"fixmap\". This only creates the header. <code>s</code> number of map items should be written via other methods after this is called.</p> <p>fixmap stores a map whose length is upto 15 elements.</p> <p>Attempting to encode a value larger than 15 will result in an <code>error</code>.</p> <pre><code>fun box fixmap(\n  b: Writer ref,\n  s: U8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_32","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_33","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#map_16","title":"map_16","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"map_16\". This only creates the header. <code>s</code> number of map items should be written via other methods after this is called.</p> <p>map 16 stores an array whose length is upto (2^16)-1 elements.</p> <p>Attempting to encode a value larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box map_16(\n  b: Writer ref,\n  s: U16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_33","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_34","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#map_32","title":"map_32","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"map_32\". This only creates the header. <code>s</code> number of map items should be written via other methods after this is called.</p> <p>map 32 stores an array whose length is upto (2^32)-1 elements.</p> <p>Attempting to encode a value larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box map_32(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_34","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_35","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_1","title":"fixext_1","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 1 stores an integer and a byte array whose length is 1 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 1 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_1(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_35","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_36","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_2","title":"fixext_2","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 2 stores an integer and a byte array whose length is 2 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 2 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_2(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_36","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_37","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_4","title":"fixext_4","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 4 stores an integer and a byte array whose length is 4 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 4 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_4(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_37","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_38","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_8","title":"fixext_8","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 8 stores an integer and a byte array whose length is 8 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 8 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_8(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_38","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_39","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_16","title":"fixext_16","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 16 stores an integer and a byte array whose length is 16 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 16 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_16(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_39","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_40","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext_8","title":"ext_8","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> that is larger than (2^8)-1 bytes in size will result in an <code>error</code>.</p> <pre><code>fun box ext_8(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_40","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_41","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext_16","title":"ext_16","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> that is larger than (2^16)-1 bytes in size will result in an <code>error</code>.</p> <pre><code>fun box ext_16(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_41","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_42","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext_32","title":"ext_32","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> that is larger than (2^32)-1 bytes in size will result in an <code>error</code>.</p> <pre><code>fun box ext_32(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_42","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_43","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp_32","title":"timestamp_32","text":"<p>[Source]</p> <p>timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in a 32-bit unsigned integer.</p> <p>It can represent a timestamp in [1970-01-01 00:00:00 UTC, 2106-02-07 06:28:16 UTC).</p> <p>Nanoseconds part is 0.</p> <pre><code>fun box timestamp_32(\n  b: Writer ref,\n  sec: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_43","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_44","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp_64","title":"timestamp_64","text":"<p>[Source]</p> <p>timestamp 64 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers.</p> <p>It can represent a timestamp in [1970-01-01 00:00:00.000000000 UTC, 2514-05-30 01:53:04.000000000 UTC).</p> <p><code>nsec</code> must not be larger than 999999999. <code>sec</code> must not be larger than (2^34 - 1).</p> <pre><code>fun box timestamp_64(\n  b: Writer ref,\n  sec: U64 val,\n  nsec: U32 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_44","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: U64 val</li> <li>nsec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_45","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp_96","title":"timestamp_96","text":"<p>[Source]</p> <p>timestamp 96 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer.</p> <p>It can represent a timestamp in [-584554047284-02-23 16:59:44 UTC, 584554051223-11-09 07:00:16.000000000 UTC).</p> <p><code>nsec</code> must not be larger than 999999999.</p> <pre><code>fun box timestamp_96(\n  b: Writer ref,\n  sec: I64 val,\n  nsec: U32 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_45","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: I64 val</li> <li>nsec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_46","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: MessagePackEncoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_46","title":"Parameters","text":"<ul> <li>that: MessagePackEncoder val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_47","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: MessagePackEncoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_47","title":"Parameters","text":"<ul> <li>that: MessagePackEncoder val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_48","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackExt/","title":"MessagePackExt","text":"<p>[Source]</p> <p>A MessagePack extension type. The <code>ext_type</code> field is the type identifier stored as a <code>U8</code>. User-defined types occupy 0 through 127. The MessagePack spec reserves -1 through -128 (signed) for predefined types (e.g., -1 for timestamps); these appear in <code>ext_type</code> as their unsigned equivalents (0xFF for -1, 0x80 for -128). The <code>data</code> field contains the raw extension bytes.</p> <pre><code>class val MessagePackExt\n</code></pre>"},{"location":"msgpack-MessagePackExt/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackExt/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  ext_type': U8 val,\n  data': Array[U8 val] val)\n: MessagePackExt val^\n</code></pre>"},{"location":"msgpack-MessagePackExt/#parameters","title":"Parameters","text":"<ul> <li>ext_type': U8 val</li> <li>data': Array[U8 val] val</li> </ul>"},{"location":"msgpack-MessagePackExt/#returns","title":"Returns","text":"<ul> <li>MessagePackExt val^</li> </ul>"},{"location":"msgpack-MessagePackExt/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackExt/#let-ext_type-u8-val","title":"let ext_type: U8 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackExt/#let-data-arrayu8-val-val","title":"let data: Array[U8 val] val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackMap/","title":"MessagePackMap","text":"<p>[Source]</p> <p>Header for a MessagePack map. The <code>size</code> field indicates how many key-value pairs follow. The caller is responsible for reading <code>size * 2</code> subsequent values (alternating keys and values).</p> <pre><code>class val MessagePackMap\n</code></pre>"},{"location":"msgpack-MessagePackMap/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackMap/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  size': U32 val)\n: MessagePackMap val^\n</code></pre>"},{"location":"msgpack-MessagePackMap/#parameters","title":"Parameters","text":"<ul> <li>size': U32 val</li> </ul>"},{"location":"msgpack-MessagePackMap/#returns","title":"Returns","text":"<ul> <li>MessagePackMap val^</li> </ul>"},{"location":"msgpack-MessagePackMap/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackMap/#let-size-u32-val","title":"let size: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackStreamingDecoder/","title":"MessagePackStreamingDecoder","text":"<p>[Source]</p> <p>A streaming-safe MessagePack decoder that never corrupts the underlying reader on insufficient data.</p> <p>Unlike <code>MessagePackDecoder</code>, which assumes all data is available and will corrupt the reader's state on partial reads, this class peeks at the format byte and any length fields before consuming any bytes. If insufficient data is available, it returns <code>NotEnoughData</code> with zero bytes consumed, allowing the caller to append more data and retry.</p> <p>Usage: <pre><code>let decoder = MessagePackStreamingDecoder\ndecoder.append(chunk1)\nmatch decoder.next()\n| let v: U32 =&gt; // got a value\n| NotEnoughData =&gt; // need more data, append and retry\n| InvalidData =&gt; // corrupt stream, abort\nend\n</code></pre></p> <p>Container types (arrays and maps) return header objects (<code>MessagePackArray</code> / <code>MessagePackMap</code>) containing the element count. The caller is responsible for subsequently reading that many values.</p> <pre><code>class ref MessagePackStreamingDecoder\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackStreamingDecoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new ref create()\n: MessagePackStreamingDecoder ref^\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns","title":"Returns","text":"<ul> <li>MessagePackStreamingDecoder ref^</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackStreamingDecoder/#append","title":"append","text":"<p>[Source]</p> <p>Append data to the internal reader. Call this as chunks arrive.</p> <pre><code>fun ref append(\n  data: (String val | Array[U8 val] val))\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#parameters","title":"Parameters","text":"<ul> <li>data: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns_1","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#next","title":"next","text":"<p>[Source]</p> <p>Attempt to decode the next MessagePack value.</p> <p>Returns one of: - A <code>MessagePackValue</code> if a complete value was decoded - <code>NotEnoughData</code> if more bytes are needed (no bytes consumed) - <code>InvalidData</code> if the format byte is invalid (0xC1).   The invalid byte is NOT consumed. The caller must stop   calling <code>next()</code> after receiving <code>InvalidData</code> \u2014 the   stream is corrupt and cannot be resynced.</p> <pre><code>fun ref next()\n: (None val | Bool val | U8 val | \n    U16 val | U32 val | U64 val | \n    I8 val | I16 val | I32 val | \n    I64 val | F32 val | F64 val | \n    String val | Array[U8 val] val | MessagePackArray val | \n    MessagePackMap val | MessagePackExt val | MessagePackTimestamp val | \n    NotEnoughData val | InvalidData val)\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns_2","title":"Returns","text":"<ul> <li>(None val | Bool val | U8 val |      U16 val | U32 val | U64 val |      I8 val | I16 val | I32 val |      I64 val | F32 val | F64 val |      String val | Array[U8 val] val | MessagePackArray val |      MessagePackMap val | MessagePackExt val | MessagePackTimestamp val |      NotEnoughData val | InvalidData val)</li> </ul>"},{"location":"msgpack-MessagePackTimestamp/","title":"MessagePackTimestamp","text":"<p>[Source]</p> <p>A decoded MessagePack timestamp. The <code>sec</code> field is the number of seconds since 1970-01-01 00:00:00 UTC (can be negative for dates before the epoch). The <code>nsec</code> field is the nanoseconds component (0 to 999999999).</p> <pre><code>class val MessagePackTimestamp\n</code></pre>"},{"location":"msgpack-MessagePackTimestamp/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackTimestamp/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  sec': I64 val,\n  nsec': U32 val)\n: MessagePackTimestamp val^\n</code></pre>"},{"location":"msgpack-MessagePackTimestamp/#parameters","title":"Parameters","text":"<ul> <li>sec': I64 val</li> <li>nsec': U32 val</li> </ul>"},{"location":"msgpack-MessagePackTimestamp/#returns","title":"Returns","text":"<ul> <li>MessagePackTimestamp val^</li> </ul>"},{"location":"msgpack-MessagePackTimestamp/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackTimestamp/#let-sec-i64-val","title":"let sec: I64 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackTimestamp/#let-nsec-u32-val","title":"let nsec: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackType/","title":"MessagePackType","text":"<p>[Source] <pre><code>type MessagePackType is\n  U8 val\n</code></pre></p>"},{"location":"msgpack-MessagePackType/#type-alias-for","title":"Type Alias For","text":"<ul> <li>U8 val</li> </ul>"},{"location":"msgpack-MessagePackValue/","title":"MessagePackValue","text":"<p>[Source] <pre><code>type MessagePackValue is\n  (None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val)\n</code></pre></p>"},{"location":"msgpack-MessagePackValue/#type-alias-for","title":"Type Alias For","text":"<ul> <li>(None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val)</li> </ul>"},{"location":"msgpack-NotEnoughData/","title":"NotEnoughData","text":"<p>[Source]</p> <p>Returned when the reader doesn't have enough data to decode the next value. The caller should append more data and retry. No bytes have been consumed from the reader.</p> <pre><code>primitive val NotEnoughData\n</code></pre>"},{"location":"msgpack-NotEnoughData/#constructors","title":"Constructors","text":""},{"location":"msgpack-NotEnoughData/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: NotEnoughData val^\n</code></pre>"},{"location":"msgpack-NotEnoughData/#returns","title":"Returns","text":"<ul> <li>NotEnoughData val^</li> </ul>"},{"location":"msgpack-NotEnoughData/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-NotEnoughData/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: NotEnoughData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-NotEnoughData/#parameters","title":"Parameters","text":"<ul> <li>that: NotEnoughData val</li> </ul>"},{"location":"msgpack-NotEnoughData/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-NotEnoughData/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: NotEnoughData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-NotEnoughData/#parameters_1","title":"Parameters","text":"<ul> <li>that: NotEnoughData val</li> </ul>"},{"location":"msgpack-NotEnoughData/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"}]}