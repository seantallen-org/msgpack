{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"msgpack--index/","title":"Pony MessagePack","text":"<p>Pure Pony implementation of the MessagePack serialization format.</p> <p>Four public APIs are available:</p> <ul> <li> <p><code>MessagePackEncoder</code> \u2014 Stateless encoding methods. Compact methods   (<code>uint</code>, <code>int</code>, <code>str</code>, <code>bin</code>, <code>array</code>, <code>map</code>, <code>ext</code>, <code>timestamp</code>)   automatically select the smallest wire format. Format-specific methods   (<code>uint_8</code>, <code>uint_32</code>, <code>fixstr</code>, <code>str_8</code>, etc.) are available for   explicit control.</p> </li> <li> <p><code>MessagePackDecoder</code> \u2014 Stateless decoding methods that work with   <code>buffered.Reader</code>. Compact methods (<code>uint</code>, <code>int</code>, <code>str</code>, <code>array</code>,   <code>map</code>) accept any wire format within a format family. Format-specific   methods are available when the caller knows the exact wire format.   Assumes all data is available; not suitable for streaming.</p> </li> <li> <p><code>MessagePackZeroCopyDecoder</code> \u2014 Zero-copy decoding methods that work   with <code>ZeroCopyReader</code>. Same API as <code>MessagePackDecoder</code> but returns   <code>String val</code> and <code>Array[U8] val</code> views into the reader's buffer   instead of copying. Use this when you need to avoid allocation   overhead for large string and binary payloads.</p> </li> <li> <p><code>MessagePackStreamingDecoder</code> \u2014 A streaming-safe decoder that peeks   before consuming bytes. Returns <code>NotEnoughData</code> when more bytes are   needed, with zero bytes consumed. Uses zero-copy decoding internally.</p> </li> </ul>"},{"location":"msgpack--index/#encoding-and-decoding-scalar-values","title":"Encoding and Decoding Scalar Values","text":"<p>Compact methods pick the smallest wire format automatically:</p> <pre><code>use \"buffered\"\nuse \"msgpack\"\n\n// Encode\nlet w: Writer ref = Writer\nMessagePackEncoder.nil(w)\nMessagePackEncoder.bool(w, true)\nMessagePackEncoder.uint(w, 42)       // positive_fixint (1 byte)\nMessagePackEncoder.str(w, \"hello\")?  // fixstr (6 bytes)\n\n// Transfer encoded bytes to a reader\nlet r: Reader ref = Reader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\n// Decode \u2014 compact methods accept any format in the family\nMessagePackDecoder.nil(r)?\nlet b = MessagePackDecoder.bool(r)?\nlet n = MessagePackDecoder.uint(r)?\nlet s = MessagePackDecoder.str(r)?\n</code></pre> <p>Format-specific methods (<code>uint_32</code>, <code>fixstr</code>, <code>str_8</code>, etc.) are available when you need explicit control over the wire format.</p>"},{"location":"msgpack--index/#encoding-and-decoding-arrays","title":"Encoding and Decoding Arrays","text":"<p>Array and map methods only write or read headers containing the element count. The caller must encode or decode each element individually.</p> <pre><code>// Encode a 3-element array of U32\nlet w: Writer ref = Writer\nMessagePackEncoder.array(w, 3)  // picks fixarray\nMessagePackEncoder.uint(w, 1)\nMessagePackEncoder.uint(w, 2)\nMessagePackEncoder.uint(w, 3)\n\n// Decode\nlet r: Reader ref = Reader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\nlet count = MessagePackDecoder.array(r)?\nvar i: U32 = 0\nwhile i &lt; count do\n  let v = MessagePackDecoder.uint(r)?\n  // use v\n  i = i + 1\nend\n</code></pre>"},{"location":"msgpack--index/#encoding-and-decoding-maps","title":"Encoding and Decoding Maps","text":"<p>Map entries are key-value pairs. The header specifies the number of pairs. Keys and values are encoded alternately.</p> <pre><code>// Encode a 2-entry map: \"a\" =&gt; 1, \"b\" =&gt; 2\nlet w: Writer ref = Writer\nMessagePackEncoder.map(w, 2)       // picks fixmap\nMessagePackEncoder.str(w, \"a\")?\nMessagePackEncoder.uint(w, 1)\nMessagePackEncoder.str(w, \"b\")?\nMessagePackEncoder.uint(w, 2)\n\n// Decode\nlet r: Reader ref = Reader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\nlet count = MessagePackDecoder.map(r)?\nvar i: U32 = 0\nwhile i &lt; count do\n  let key = MessagePackDecoder.str(r)?\n  let value = MessagePackDecoder.uint(r)?\n  // use key and value\n  i = i + 1\nend\n</code></pre>"},{"location":"msgpack--index/#streaming-decoder","title":"Streaming Decoder","text":"<p><code>MessagePackStreamingDecoder</code> is safe for incremental data. It returns <code>MessagePackArray</code> or <code>MessagePackMap</code> header objects for containers; the caller then reads the elements.</p> <pre><code>let sd = MessagePackStreamingDecoder\nsd.append(data)\n\nmatch sd.next()\n| None =&gt; None // decoded nil\n| let v: U32 =&gt; None // decoded a U32\n| let a: MessagePackArray =&gt;\n  // read a.size elements\n  var i: U32 = 0\n  while i &lt; a.size do\n    match sd.next()\n    | let v: U32 =&gt; None // use v\n    end\n    i = i + 1\n  end\n| let m: MessagePackMap =&gt;\n  // read m.size key-value pairs\n  var i: U32 = 0\n  while i &lt; m.size do\n    match sd.next()\n    | let key: String val =&gt; None\n    end\n    match sd.next()\n    | let value: U32 =&gt; None\n    end\n    i = i + 1\n  end\n| NotEnoughData =&gt; None // need more bytes\n| LimitExceeded =&gt; None // value too large\n| InvalidData =&gt; None // stream is corrupt\nend\n</code></pre>"},{"location":"msgpack--index/#zero-copy-decoding","title":"Zero-Copy Decoding","text":"<p><code>ZeroCopyReader</code> + <code>MessagePackZeroCopyDecoder</code> provide zero-copy decoding as an alternative to <code>buffered.Reader</code> + <code>MessagePackDecoder</code>. When string or binary data falls within a single chunk, the decoder returns a shared view into the reader's buffer \u2014 no allocation or copy. When data spans chunk boundaries, it falls back to copying.</p> <p><code>MessagePackStreamingDecoder</code> uses zero-copy decoding internally. Callers get the benefit automatically with no code changes.</p> <p>For low-level decoding where you want zero-copy directly:</p> <pre><code>use \"buffered\"\nuse \"msgpack\"\n\nlet w: Writer ref = Writer\nMessagePackEncoder.str(w, \"hello\")?\n\nlet r = ZeroCopyReader\nfor bs in w.done().values() do\n  r.append(bs)\nend\n\nlet s = MessagePackZeroCopyDecoder.str(r)?\n</code></pre> <p>Tradeoff: <code>ZeroCopyReader</code> is specific to this package and is not interoperable with APIs that expect <code>buffered.Reader</code>. Decoded values may hold references to the reader's internal chunks, pinning them in memory until the decoded value is discarded. For most use cases (decode, process, discard) this is not a concern.</p>"},{"location":"msgpack--index/#decoding-untrusted-data","title":"Decoding Untrusted Data","text":"<p>MessagePack headers declare the size of variable-length values (strings, byte arrays, extensions) and the element count of containers (arrays, maps). A malicious or malformed payload can claim sizes far larger than the actual data \u2014 for example, a 5-byte message whose header declares a 2 GB string. Without limits, a decoder may attempt to allocate memory proportional to the declared size, enabling denial-of-service attacks.</p> <p><code>MessagePackDecoder</code> provides no protection. It trusts the declared sizes and will attempt to read whatever the header says. Use it only when you control both ends of the connection or have already validated the payload.</p> <p><code>MessagePackStreamingDecoder</code> enforces size limits. By default, conservative limits are applied: 1 MB for str/bin/ext data and 131,072 for array/map element counts. When a value exceeds its limit, <code>next()</code> returns <code>LimitExceeded</code> with zero bytes consumed.</p> <p>For network-facing code that decodes data from untrusted sources, use <code>MessagePackStreamingDecoder</code>:</p> <pre><code>// Default limits \u2014 safe for most applications:\nlet sd = MessagePackStreamingDecoder\n\n// Tighter limits for a constrained protocol:\nlet limits = MessagePackDecodeLimits(\n  where max_str_len' = 4096,\n        max_array_len' = 100)\nlet sd = MessagePackStreamingDecoder(limits)\n\n// No limits (trusted data only):\nlet sd = MessagePackStreamingDecoder(\n  MessagePackDecodeLimits.unlimited())\n</code></pre> <p>See <code>MessagePackDecodeLimits</code> for the full set of configurable limits.</p>"},{"location":"msgpack--index/#utf-8-validation","title":"UTF-8 Validation","text":"<p>The MessagePack spec defines the str format family as UTF-8 strings. By default, this library does not validate UTF-8 \u2014 str values are treated as raw byte sequences for backward compatibility and performance. Opt-in validation is available at every layer:</p> <p>Validating method variants \u2014 Append <code>_utf8</code> to any str encoding or decoding method. These validate UTF-8 and error on invalid byte sequences:</p> <pre><code>// Encode \u2014 errors if bytes are not valid UTF-8\nMessagePackEncoder.str_utf8(w, value)?\n\n// Decode \u2014 errors if decoded bytes are not valid UTF-8\nlet s = MessagePackDecoder.str_utf8(r)?\nlet s = MessagePackZeroCopyDecoder.str_utf8(r)?\n</code></pre> <p>Streaming decoder \u2014 Pass <code>validate_utf8' = true</code> to the constructor. Invalid str values return <code>InvalidUtf8</code> instead of the decoded string:</p> <pre><code>let sd = MessagePackStreamingDecoder(\n  where validate_utf8' = true)\nmatch sd.next()\n| let s: String val =&gt; // valid UTF-8\n| InvalidUtf8 =&gt; // invalid UTF-8, can continue decoding\nend\n</code></pre> <p>Decode then validate \u2014 Use <code>MessagePackValidateUTF8</code> for caller-side validation when you need access to the raw bytes on failure:</p> <pre><code>let s = MessagePackDecoder.str(r)?\nif not MessagePackValidateUTF8(s) then\n  // s still available \u2014 log, reject, or use as raw bytes\nend\n</code></pre>"},{"location":"msgpack--index/#public-types","title":"Public Types","text":"<ul> <li>type DecodeResult</li> <li>primitive InvalidData</li> <li>primitive InvalidUtf8</li> <li>primitive LimitExceeded</li> <li>class MessagePackArray</li> <li>class MessagePackDecodeLimits</li> <li>primitive MessagePackDecoder</li> <li>primitive MessagePackEncoder</li> <li>class MessagePackExt</li> <li>class MessagePackMap</li> <li>class MessagePackStreamingDecoder</li> <li>class MessagePackTimestamp</li> <li>type MessagePackType</li> <li>primitive MessagePackValidateUTF8</li> <li>type MessagePackValue</li> <li>primitive MessagePackZeroCopyDecoder</li> <li>primitive NotEnoughData</li> <li>type SkipResult</li> <li>class ZeroCopyReader</li> </ul>"},{"location":"msgpack-DecodeResult/","title":"DecodeResult","text":"<p>[Source] <pre><code>type DecodeResult is\n  (None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val | NotEnoughData val | InvalidData val | InvalidUtf8 val | LimitExceeded val)\n</code></pre></p>"},{"location":"msgpack-DecodeResult/#type-alias-for","title":"Type Alias For","text":"<ul> <li>(None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val | NotEnoughData val | InvalidData val | InvalidUtf8 val | LimitExceeded val)</li> </ul>"},{"location":"msgpack-InvalidData/","title":"InvalidData","text":"<p>[Source]</p> <p>Returned when the data contains an invalid MessagePack format byte. The stream is corrupt and decoding should stop.</p> <pre><code>primitive val InvalidData\n</code></pre>"},{"location":"msgpack-InvalidData/#constructors","title":"Constructors","text":""},{"location":"msgpack-InvalidData/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: InvalidData val^\n</code></pre>"},{"location":"msgpack-InvalidData/#returns","title":"Returns","text":"<ul> <li>InvalidData val^</li> </ul>"},{"location":"msgpack-InvalidData/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-InvalidData/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: InvalidData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-InvalidData/#parameters","title":"Parameters","text":"<ul> <li>that: InvalidData val</li> </ul>"},{"location":"msgpack-InvalidData/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-InvalidData/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: InvalidData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-InvalidData/#parameters_1","title":"Parameters","text":"<ul> <li>that: InvalidData val</li> </ul>"},{"location":"msgpack-InvalidData/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-InvalidUtf8/","title":"InvalidUtf8","text":"<p>[Source]</p> <p>Returned when a decoded string value contains invalid UTF-8 byte sequences. The MessagePack framing is valid and decoding can continue.</p> <pre><code>primitive val InvalidUtf8\n</code></pre>"},{"location":"msgpack-InvalidUtf8/#constructors","title":"Constructors","text":""},{"location":"msgpack-InvalidUtf8/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: InvalidUtf8 val^\n</code></pre>"},{"location":"msgpack-InvalidUtf8/#returns","title":"Returns","text":"<ul> <li>InvalidUtf8 val^</li> </ul>"},{"location":"msgpack-InvalidUtf8/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-InvalidUtf8/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: InvalidUtf8 val)\n: Bool val\n</code></pre>"},{"location":"msgpack-InvalidUtf8/#parameters","title":"Parameters","text":"<ul> <li>that: InvalidUtf8 val</li> </ul>"},{"location":"msgpack-InvalidUtf8/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-InvalidUtf8/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: InvalidUtf8 val)\n: Bool val\n</code></pre>"},{"location":"msgpack-InvalidUtf8/#parameters_1","title":"Parameters","text":"<ul> <li>that: InvalidUtf8 val</li> </ul>"},{"location":"msgpack-InvalidUtf8/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-LimitExceeded/","title":"LimitExceeded","text":"<p>[Source]</p> <p>Returned when a decoded value's size or element count exceeds the configured limit. No bytes have been consumed from the reader. The caller should treat this as a rejected message.</p> <pre><code>primitive val LimitExceeded\n</code></pre>"},{"location":"msgpack-LimitExceeded/#constructors","title":"Constructors","text":""},{"location":"msgpack-LimitExceeded/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: LimitExceeded val^\n</code></pre>"},{"location":"msgpack-LimitExceeded/#returns","title":"Returns","text":"<ul> <li>LimitExceeded val^</li> </ul>"},{"location":"msgpack-LimitExceeded/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-LimitExceeded/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: LimitExceeded val)\n: Bool val\n</code></pre>"},{"location":"msgpack-LimitExceeded/#parameters","title":"Parameters","text":"<ul> <li>that: LimitExceeded val</li> </ul>"},{"location":"msgpack-LimitExceeded/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-LimitExceeded/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: LimitExceeded val)\n: Bool val\n</code></pre>"},{"location":"msgpack-LimitExceeded/#parameters_1","title":"Parameters","text":"<ul> <li>that: LimitExceeded val</li> </ul>"},{"location":"msgpack-LimitExceeded/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackArray/","title":"MessagePackArray","text":"<p>[Source]</p> <p>Header for a MessagePack array. The <code>size</code> field indicates how many elements follow. The caller is responsible for reading <code>size</code> subsequent values.</p> <pre><code>class val MessagePackArray\n</code></pre>"},{"location":"msgpack-MessagePackArray/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackArray/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  size': U32 val)\n: MessagePackArray val^\n</code></pre>"},{"location":"msgpack-MessagePackArray/#parameters","title":"Parameters","text":"<ul> <li>size': U32 val</li> </ul>"},{"location":"msgpack-MessagePackArray/#returns","title":"Returns","text":"<ul> <li>MessagePackArray val^</li> </ul>"},{"location":"msgpack-MessagePackArray/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackArray/#let-size-u32-val","title":"let size: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/","title":"MessagePackDecodeLimits","text":"<p>[Source]</p> <p>Limits for the streaming decoder. Protects against denial-of-service attacks where a malicious payload claims enormous sizes for variable-length values or deeply nested containers.</p> <p>The default constructor applies conservative limits: 1 MB for str/bin/ext data, 131,072 for array/map element counts, and 512 for container nesting depth. Use <code>unlimited()</code> to disable all limits, or override individual limits:</p> <pre><code>// Default conservative limits:\nlet limits = MessagePackDecodeLimits\n\n// Custom limits:\nlet limits = MessagePackDecodeLimits(\n  where max_str_len' = 4096)\n\n// No limits:\nlet limits = MessagePackDecodeLimits.unlimited()\n</code></pre> <pre><code>class val MessagePackDecodeLimits\n</code></pre>"},{"location":"msgpack-MessagePackDecodeLimits/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackDecodeLimits/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  max_str_len': USize val = 1048576,\n  max_bin_len': USize val = 1048576,\n  max_ext_len': USize val = 1048576,\n  max_array_len': U32 val = 131072,\n  max_map_len': U32 val = 131072,\n  max_depth': USize val = 512,\n  max_skip_values': USize val = 1048576)\n: MessagePackDecodeLimits val^\n</code></pre>"},{"location":"msgpack-MessagePackDecodeLimits/#parameters","title":"Parameters","text":"<ul> <li>max_str_len': USize val = 1048576</li> <li>max_bin_len': USize val = 1048576</li> <li>max_ext_len': USize val = 1048576</li> <li>max_array_len': U32 val = 131072</li> <li>max_map_len': U32 val = 131072</li> <li>max_depth': USize val = 512</li> <li>max_skip_values': USize val = 1048576</li> </ul>"},{"location":"msgpack-MessagePackDecodeLimits/#returns","title":"Returns","text":"<ul> <li>MessagePackDecodeLimits val^</li> </ul>"},{"location":"msgpack-MessagePackDecodeLimits/#unlimited","title":"unlimited","text":"<p>[Source]</p> <pre><code>new val unlimited()\n: MessagePackDecodeLimits val^\n</code></pre>"},{"location":"msgpack-MessagePackDecodeLimits/#returns_1","title":"Returns","text":"<ul> <li>MessagePackDecodeLimits val^</li> </ul>"},{"location":"msgpack-MessagePackDecodeLimits/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackDecodeLimits/#let-max_str_len-usize-val","title":"let max_str_len: USize val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/#let-max_bin_len-usize-val","title":"let max_bin_len: USize val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/#let-max_ext_len-usize-val","title":"let max_ext_len: USize val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/#let-max_array_len-u32-val","title":"let max_array_len: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/#let-max_map_len-u32-val","title":"let max_map_len: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/#let-max_depth-usize-val","title":"let max_depth: USize val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecodeLimits/#let-max_skip_values-usize-val","title":"let max_skip_values: USize val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackDecoder/","title":"MessagePackDecoder","text":"<p>[Source]</p> <p>Implements low-level decoding from the MessagePack serialization format.</p> <p>You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from incorrectly decoding documents. This is particularly true when using the <code>array</code> and <code>map</code> format family decoding methods, which only read headers \u2014 the caller must read each element individually afterward.</p> <p>Two styles of decode methods are provided:</p> <ul> <li>Compact methods (<code>uint</code>, <code>int</code>, <code>str</code>, <code>byte_array</code>, <code>ext</code>,   <code>array</code>, <code>map</code>) peek at the format byte to determine the wire   format and accept any format within the family.</li> <li>Format-specific methods (<code>u8</code>, <code>u16</code>, <code>str_8</code>, <code>str_16</code>,   <code>bin_8</code>, <code>fixext_1</code>, <code>ext_8</code>, etc.) validate a single expected   format byte, then read the data directly. Use these when you   know the exact wire format in advance.</li> </ul> <p>This decoder assumes all data is available when decoding begins. If data may arrive incrementally, use <code>MessagePackStreamingDecoder</code> instead.</p> <pre><code>primitive val MessagePackDecoder\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackDecoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: MessagePackDecoder val^\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#returns","title":"Returns","text":"<ul> <li>MessagePackDecoder val^</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackDecoder/#uint","title":"uint","text":"<p>[Source]</p> <p>Decodes an unsigned integer from any uint or positive fixint format.</p> <pre><code>fun box uint(\n  b: Reader ref)\n: U64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_1","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#int","title":"int","text":"<p>[Source]</p> <p>Decodes a signed integer from any int, uint, or fixint format. Errors if a uint_64 value exceeds I64.max_value().</p> <pre><code>fun box int(\n  b: Reader ref)\n: I64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_1","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_2","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#array","title":"array","text":"<p>[Source]</p> <p>Reads an array header from any array format. Returns the element count. The caller must read that many elements afterward.</p> <pre><code>fun box array(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_2","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_3","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#map","title":"map","text":"<p>[Source]</p> <p>Reads a map header from any map format. Returns the pair count. The caller must read that many key-value pairs afterward.</p> <pre><code>fun box map(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_3","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_4","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#nil","title":"nil","text":"<p>[Source]</p> <p>Returns nothing. Throws an error if the next byte isn't a MessagePack nil.</p> <pre><code>fun box nil(\n  b: Reader ref)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_4","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_5","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bool","title":"bool","text":"<p>[Source]</p> <pre><code>fun box bool(\n  b: Reader ref)\n: Bool val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_5","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_6","title":"Returns","text":"<ul> <li>Bool val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#positive_fixint","title":"positive_fixint","text":"<p>[Source]</p> <pre><code>fun box positive_fixint(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_6","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_7","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#negative_fixint","title":"negative_fixint","text":"<p>[Source]</p> <pre><code>fun box negative_fixint(\n  b: Reader ref)\n: I8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_7","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_8","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u8","title":"u8","text":"<p>[Source]</p> <pre><code>fun box u8(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_8","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_9","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u16","title":"u16","text":"<p>[Source]</p> <pre><code>fun box u16(\n  b: Reader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_9","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_10","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u32","title":"u32","text":"<p>[Source]</p> <pre><code>fun box u32(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_10","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_11","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#u64","title":"u64","text":"<p>[Source]</p> <pre><code>fun box u64(\n  b: Reader ref)\n: U64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_11","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_12","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i8","title":"i8","text":"<p>[Source]</p> <pre><code>fun box i8(\n  b: Reader ref)\n: I8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_12","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_13","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i16","title":"i16","text":"<p>[Source]</p> <pre><code>fun box i16(\n  b: Reader ref)\n: I16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_13","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_14","title":"Returns","text":"<ul> <li>I16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i32","title":"i32","text":"<p>[Source]</p> <pre><code>fun box i32(\n  b: Reader ref)\n: I32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_14","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_15","title":"Returns","text":"<ul> <li>I32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#i64","title":"i64","text":"<p>[Source]</p> <pre><code>fun box i64(\n  b: Reader ref)\n: I64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_15","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_16","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#f32","title":"f32","text":"<p>[Source]</p> <pre><code>fun box f32(\n  b: Reader ref)\n: F32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_16","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_17","title":"Returns","text":"<ul> <li>F32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#f64","title":"f64","text":"<p>[Source]</p> <pre><code>fun box f64(\n  b: Reader ref)\n: F64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_17","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_18","title":"Returns","text":"<ul> <li>F64 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixstr","title":"fixstr","text":"<p>[Source]</p> <pre><code>fun box fixstr(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_18","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_19","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str","title":"str","text":"<p>[Source]</p> <pre><code>fun box str(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_19","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_20","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_8","title":"str_8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 8 value. Validates that the format byte is str_8 (0xD9), then reads the 1-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_20","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_21","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_16","title":"str_16","text":"<p>[Source]</p> <p>Decodes a MessagePack str 16 value. Validates that the format byte is str_16 (0xDA), then reads the 2-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_16(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_21","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_22","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_32","title":"str_32","text":"<p>[Source]</p> <p>Decodes a MessagePack str 32 value. Validates that the format byte is str_32 (0xDB), then reads the 4-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_32(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_22","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_23","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_utf8","title":"str_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str value using the smallest matching format, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte is not a str type, if insufficient data is available, or if the decoded bytes are not valid UTF-8. On a UTF-8 validation error the bytes have already been consumed from the reader. For the non-validating variant, use <code>str()</code>. To retain access to the raw bytes on validation failure, use <code>str()</code> followed by <code>MessagePackValidateUTF8</code>.</p> <pre><code>fun box str_utf8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_23","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_24","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixstr_utf8","title":"fixstr_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack fixstr value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>fixstr()</code>.</p> <pre><code>fun box fixstr_utf8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_24","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_25","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_8_utf8","title":"str_8_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 8 value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>str_8()</code>.</p> <pre><code>fun box str_8_utf8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_25","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_26","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_16_utf8","title":"str_16_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 16 value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>str_16()</code>.</p> <pre><code>fun box str_16_utf8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_26","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_27","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#str_32_utf8","title":"str_32_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 32 value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>str_32()</code>.</p> <pre><code>fun box str_32_utf8(\n  b: Reader ref)\n: String iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_27","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_28","title":"Returns","text":"<ul> <li>String iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#byte_array","title":"byte_array","text":"<p>[Source]</p> <pre><code>fun box byte_array(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_28","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_29","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bin_8","title":"bin_8","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 8 value. Validates that the format byte is bin_8 (0xC4), then reads the 1-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_8(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_29","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_30","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bin_16","title":"bin_16","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 16 value. Validates that the format byte is bin_16 (0xC5), then reads the 2-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_16(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_30","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_31","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#bin_32","title":"bin_32","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 32 value. Validates that the format byte is bin_32 (0xC6), then reads the 4-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_32(\n  b: Reader ref)\n: Array[U8 val] iso^ ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_31","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_32","title":"Returns","text":"<ul> <li>Array[U8 val] iso^ ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixarray","title":"fixarray","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"fixarray\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box fixarray(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_32","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_33","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#array_16","title":"array_16","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"array_16\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box array_16(\n  b: Reader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_33","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_34","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#array_32","title":"array_32","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"array_32\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box array_32(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_34","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_35","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixmap","title":"fixmap","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"fixmap\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box fixmap(\n  b: Reader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_35","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_36","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#map_16","title":"map_16","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"map_16\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box map_16(\n  b: Reader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_36","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_37","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#map_32","title":"map_32","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"map_32\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box map_32(\n  b: Reader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_37","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_38","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext","title":"ext","text":"<p>[Source]</p> <p>Allows for the reading of user supplied extensions to the MessagePack format.</p> <p>fixext * types return a tuple representing:</p> <p>(user supplied type indentifier, data byte array)</p> <pre><code>fun box ext(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_38","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_39","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_1","title":"fixext_1","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 1 value. Validates that the format byte is fixext_1 (0xD4), then reads the ext type byte and 1 byte of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_1(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_39","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_40","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_2","title":"fixext_2","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 2 value. Validates that the format byte is fixext_2 (0xD5), then reads the ext type byte and 2 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_2(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_40","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_41","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_4","title":"fixext_4","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 4 value. Validates that the format byte is fixext_4 (0xD6), then reads the ext type byte and 4 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_4(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_41","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_42","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_8","title":"fixext_8","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 8 value. Validates that the format byte is fixext_8 (0xD7), then reads the ext type byte and 8 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_8(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_42","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_43","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#fixext_16","title":"fixext_16","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 16 value. Validates that the format byte is fixext_16 (0xD8), then reads the ext type byte and 16 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_16(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_43","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_44","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext_8","title":"ext_8","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 8 value. Validates that the format byte is ext_8 (0xC7), then reads the 1-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_8(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_44","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_45","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext_16","title":"ext_16","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 16 value. Validates that the format byte is ext_16 (0xC8), then reads the 2-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_16(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_45","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_46","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ext_32","title":"ext_32","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 32 value. Validates that the format byte is ext_32 (0xC9), then reads the 4-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_32(\n  b: Reader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_46","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_47","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#timestamp","title":"timestamp","text":"<p>[Source]</p> <pre><code>fun box timestamp(\n  b: Reader ref)\n: (I64 val , U32 val) ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_47","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_48","title":"Returns","text":"<ul> <li>(I64 val , U32 val) ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#skip","title":"skip","text":"<p>[Source]</p> <p>Advances past one complete MessagePack value without decoding it. For containers (arrays and maps), skips all contained elements.</p> <p>Errors if insufficient data is available or if the format byte is invalid (0xC1). On error, no bytes are consumed.</p> <p>This method has no limit on the number of values traversed. For protection against container amplification attacks, use <code>MessagePackStreamingDecoder.skip</code> which enforces a configurable <code>max_skip_values</code> limit.</p> <pre><code>fun box skip(\n  b: Reader ref)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_48","title":"Parameters","text":"<ul> <li>b: Reader ref</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_49","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: MessagePackDecoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_49","title":"Parameters","text":"<ul> <li>that: MessagePackDecoder val</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_50","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: MessagePackDecoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackDecoder/#parameters_50","title":"Parameters","text":"<ul> <li>that: MessagePackDecoder val</li> </ul>"},{"location":"msgpack-MessagePackDecoder/#returns_51","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/","title":"MessagePackEncoder","text":"<p>[Source]</p> <p>Implements low-level encoding into the MessagePack serialization format.</p> <p>You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from creating invalid documents. This is particularly true when using the <code>array</code> and <code>map</code> format family encoding methods, which only write headers \u2014 the caller must write each element individually afterward.</p> <p>For decoding, see <code>MessagePackDecoder</code> (all-at-once) or <code>MessagePackStreamingDecoder</code> (incremental/streaming).</p> <pre><code>primitive val MessagePackEncoder\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackEncoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: MessagePackEncoder val^\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#returns","title":"Returns","text":"<ul> <li>MessagePackEncoder val^</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackEncoder/#uint","title":"uint","text":"<p>[Source]</p> <p>Encodes an unsigned integer using the smallest format that fits the value.</p> <pre><code>fun box uint(\n  b: Writer ref,\n  v: U64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_1","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int","title":"int","text":"<p>[Source]</p> <p>Encodes a signed integer using the smallest format that fits the value. Positive values use unsigned formats when smaller, per the MessagePack spec (all int/uint formats are one family).</p> <pre><code>fun box int(\n  b: Writer ref,\n  v: I64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_1","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_2","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str","title":"str","text":"<p>[Source]</p> <p>Encodes a string using the smallest format that fits the byte length.</p> <pre><code>fun box str(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_2","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_3","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin","title":"bin","text":"<p>[Source]</p> <p>Encodes a binary byte array using the smallest format that fits the byte length.</p> <pre><code>fun box bin(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_3","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_4","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#array","title":"array","text":"<p>[Source]</p> <p>Creates an array header using the smallest format that fits the element count. The caller must write <code>s</code> elements after this call.</p> <pre><code>fun box array(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_4","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_5","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#map","title":"map","text":"<p>[Source]</p> <p>Creates a map header using the smallest format that fits the pair count. The caller must write <code>s</code> key-value pairs after this call.</p> <pre><code>fun box map(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_5","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_6","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext","title":"ext","text":"<p>[Source]</p> <p>Encodes an extension value using the smallest format that fits the data length. Prefers fixext formats for sizes 1, 2, 4, 8, and 16.</p> <pre><code>fun box ext(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_6","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_7","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp","title":"timestamp","text":"<p>[Source]</p> <p>Encodes a timestamp using the smallest format that fits the value. Uses timestamp_32 when nanoseconds are zero and seconds fit in a U32, timestamp_64 when seconds fit in 34 bits, and timestamp_96 otherwise.</p> <pre><code>fun box timestamp(\n  b: Writer ref,\n  sec: I64 val,\n  nsec: U32 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_7","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: I64 val</li> <li>nsec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_8","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#nil","title":"nil","text":"<p>[Source]</p> <p>nil format stores nil in 1 byte.</p> <pre><code>fun box nil(\n  b: Writer ref)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_8","title":"Parameters","text":"<ul> <li>b: Writer ref</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_9","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bool","title":"bool","text":"<p>[Source]</p> <p>bool format family stores false or true in 1 byte.</p> <pre><code>fun box bool(\n  b: Writer ref,\n  t_or_f: Bool val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_9","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t_or_f: Bool val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_10","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#positive_fixint","title":"positive_fixint","text":"<p>[Source]</p> <p>positive fixnum stores 7-bit positive integer.</p> <ul> <li>Max value that can be encoded is <code>127</code>.</li> </ul> <p>Attemping to encode an out of range value will result in an <code>error</code>.</p> <pre><code>fun box positive_fixint(\n  b: Writer ref,\n  v: U8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_10","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_11","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#negative_fixint","title":"negative_fixint","text":"<p>[Source]</p> <p>negative fixnum stores 5-bit negative integer.</p> <ul> <li>Max value that can be encoded is <code>-1</code>.</li> <li>Min value that can be encoded is <code>-32</code>.</li> </ul> <p>Attemping to encode an out of range value will result in an <code>error</code>.</p> <pre><code>fun box negative_fixint(\n  b: Writer ref,\n  v: I8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_11","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_12","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_8","title":"uint_8","text":"<p>[Source]</p> <p>uint 8 stores a 8-bit unsigned integer.</p> <pre><code>fun box uint_8(\n  b: Writer ref,\n  v: U8 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_12","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_13","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_16","title":"uint_16","text":"<p>[Source]</p> <p>uint 16 stores a 16-bit big-endian unsigned integer.</p> <pre><code>fun box uint_16(\n  b: Writer ref,\n  v: U16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_13","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_14","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_32","title":"uint_32","text":"<p>[Source]</p> <p>uint 32 stores a 32-bit big-endian unsigned integer.</p> <pre><code>fun box uint_32(\n  b: Writer ref,\n  v: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_14","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_15","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#uint_64","title":"uint_64","text":"<p>[Source]</p> <p>uint 64 stores a 64-bit big-endian unsigned integer.</p> <pre><code>fun box uint_64(\n  b: Writer ref,\n  v: U64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_15","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: U64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_16","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_8","title":"int_8","text":"<p>[Source]</p> <p>int 8 stores a 8-bit signed integer.</p> <pre><code>fun box int_8(\n  b: Writer ref,\n  v: I8 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_16","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_17","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_16","title":"int_16","text":"<p>[Source]</p> <p>int 16 stores a 16-bit big-endian signed integer.</p> <pre><code>fun box int_16(\n  b: Writer ref,\n  v: I16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_17","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_18","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_32","title":"int_32","text":"<p>[Source]</p> <p>int 32 stores a 32-bit big-endian signed integer.</p> <pre><code>fun box int_32(\n  b: Writer ref,\n  v: I32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_18","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_19","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#int_64","title":"int_64","text":"<p>[Source]</p> <p>int 64 stores a 64-bit big-endian signed integer.</p> <pre><code>fun box int_64(\n  b: Writer ref,\n  v: I64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_19","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: I64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_20","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#float_32","title":"float_32","text":"<p>[Source]</p> <p>float 32 stores a floating point number in IEEE 754 single precision floating point number format.</p> <pre><code>fun box float_32(\n  b: Writer ref,\n  v: F32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_20","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: F32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_21","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#float_64","title":"float_64","text":"<p>[Source]</p> <p>float 64 stores a floating point number in IEEE 754 double precision floating point number format.</p> <pre><code>fun box float_64(\n  b: Writer ref,\n  v: F64 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_21","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: F64 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_22","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixstr","title":"fixstr","text":"<p>[Source]</p> <p>fixstr stores a byte array whose length is upto 31 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than 31 bytes will result in an <code>error</code>.</p> <pre><code>fun box fixstr(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_22","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_23","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_8","title":"str_8","text":"<p>[Source]</p> <p>str 8 stores a byte array whose length is upto (2^8)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^8)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box str_8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_23","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_24","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_16","title":"str_16","text":"<p>[Source]</p> <p>str 16 stores a byte array whose length is upto (2^16)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box str_16(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_24","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_25","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_32","title":"str_32","text":"<p>[Source]</p> <p>str 32 stores a byte array whose length is upto (2^32)-1.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box str_32(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_25","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_26","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_utf8","title":"str_utf8","text":"<p>[Source]</p> <p>Encodes a string using the smallest format that fits the byte length, after validating that the bytes are valid UTF-8.</p> <p>Errors if the bytes are not valid UTF-8 or if the value is too large to encode. For the non-validating variant, use <code>str()</code>.</p> <pre><code>fun box str_utf8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_26","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_27","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixstr_utf8","title":"fixstr_utf8","text":"<p>[Source]</p> <p>Encodes a fixstr value after validating that the bytes are valid UTF-8.</p> <p>Errors if the bytes are not valid UTF-8 or if the value exceeds 31 bytes. For the non-validating variant, use <code>fixstr()</code>.</p> <pre><code>fun box fixstr_utf8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_27","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_28","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_8_utf8","title":"str_8_utf8","text":"<p>[Source]</p> <p>Encodes a str 8 value after validating that the bytes are valid UTF-8.</p> <p>Errors if the bytes are not valid UTF-8 or if the value exceeds (2^8)-1 bytes. For the non-validating variant, use <code>str_8()</code>.</p> <pre><code>fun box str_8_utf8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_28","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_29","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_16_utf8","title":"str_16_utf8","text":"<p>[Source]</p> <p>Encodes a str 16 value after validating that the bytes are valid UTF-8.</p> <p>Errors if the bytes are not valid UTF-8 or if the value exceeds (2^16)-1 bytes. For the non-validating variant, use <code>str_16()</code>.</p> <pre><code>fun box str_16_utf8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_29","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_30","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#str_32_utf8","title":"str_32_utf8","text":"<p>[Source]</p> <p>Encodes a str 32 value after validating that the bytes are valid UTF-8.</p> <p>Errors if the bytes are not valid UTF-8 or if the value exceeds (2^32)-1 bytes. For the non-validating variant, use <code>str_32()</code>.</p> <pre><code>fun box str_32_utf8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_30","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_31","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin_8","title":"bin_8","text":"<p>[Source]</p> <p>bin 8 stores a byte array whose length is upto (2^8)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^8)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box bin_8(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_31","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_32","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin_16","title":"bin_16","text":"<p>[Source]</p> <p>bin 16 stores a byte array whose length is upto (2^16)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box bin_16(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_32","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_33","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#bin_32","title":"bin_32","text":"<p>[Source]</p> <p>bin 32 stores a byte array whose length is upto (2^32)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box bin_32(\n  b: Writer ref,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_33","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_34","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixarray","title":"fixarray","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"fixarray\". This only creates the header. <code>s</code> number of array items should be written via other methods after this is called.</p> <p>fixarray stores an array whose length is upto 15 elements.</p> <p>Attempting to encode a value larger than 15 will result in an <code>error</code>.</p> <pre><code>fun box fixarray(\n  b: Writer ref,\n  s: U8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_34","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_35","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#array_16","title":"array_16","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"array_16\". This only creates the header. <code>s</code> number of array items should be written via other methods after this is called.</p> <p>array 16 stores an array whose length is upto (2^16)-1 elements.</p> <p>Attempting to encode a value larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box array_16(\n  b: Writer ref,\n  s: U16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_35","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_36","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#array_32","title":"array_32","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"array_32\". This only creates the header. <code>s</code> number of array items should be written via other methods after this is called.</p> <p>array 32 stores an array whose length is upto (2^32)-1 elements.</p> <p>Attempting to encode a value larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box array_32(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_36","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_37","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixmap","title":"fixmap","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"fixmap\". This only creates the header. <code>s</code> number of map items should be written via other methods after this is called.</p> <p>fixmap stores a map whose length is upto 15 elements.</p> <p>Attempting to encode a value larger than 15 will result in an <code>error</code>.</p> <pre><code>fun box fixmap(\n  b: Writer ref,\n  s: U8 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_37","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U8 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_38","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#map_16","title":"map_16","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"map_16\". This only creates the header. <code>s</code> number of map items should be written via other methods after this is called.</p> <p>map 16 stores an array whose length is upto (2^16)-1 elements.</p> <p>Attempting to encode a value larger than (2^16)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box map_16(\n  b: Writer ref,\n  s: U16 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_38","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U16 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_39","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#map_32","title":"map_32","text":"<p>[Source]</p> <p>Creates a header for a MessagePack \"map_32\". This only creates the header. <code>s</code> number of map items should be written via other methods after this is called.</p> <p>map 32 stores an array whose length is upto (2^32)-1 elements.</p> <p>Attempting to encode a value larger than (2^32)-1 bytes will result in an <code>error</code>.</p> <pre><code>fun box map_32(\n  b: Writer ref,\n  s: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_39","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>s: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_40","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_1","title":"fixext_1","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 1 stores an integer and a byte array whose length is 1 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 1 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_1(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_40","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_41","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_2","title":"fixext_2","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 2 stores an integer and a byte array whose length is 2 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 2 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_2(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_41","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_42","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_4","title":"fixext_4","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 4 stores an integer and a byte array whose length is 4 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 4 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_4(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_42","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_43","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_8","title":"fixext_8","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 8 stores an integer and a byte array whose length is 8 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 8 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_8(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_43","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_44","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#fixext_16","title":"fixext_16","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>fixext 16 stores an integer and a byte array whose length is 16 byte.</p> <p>Attempting to encode a <code>ByteSeq</code> that is not 16 element in size will result in an <code>error</code>.</p> <pre><code>fun box fixext_16(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_44","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_45","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext_8","title":"ext_8","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>ext 8 stores an integer and a byte array whose length is upto (2^8)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> that is larger than (2^8)-1 bytes in size will result in an <code>error</code>.</p> <pre><code>fun box ext_8(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_45","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_46","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext_16","title":"ext_16","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>ext 16 stores an integer and a byte array whose length is upto (2^16)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> that is larger than (2^16)-1 bytes in size will result in an <code>error</code>.</p> <pre><code>fun box ext_16(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_46","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_47","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ext_32","title":"ext_32","text":"<p>[Source]</p> <p>Allows for the creation of user supplied extensions to the MessagePack format. User should provide not just the value <code>v</code> to be encoded, but a unique type identifier <code>t</code> as well.</p> <p>Type identifiers <code>0</code> to <code>127</code> are valid for user supplied types. MessagePack reserves -1 to -128 for future extension to add predefined types.</p> <p>ext 32 stores an integer and a byte array whose length is upto (2^32)-1 bytes.</p> <p>Attempting to encode a <code>ByteSeq</code> that is larger than (2^32)-1 bytes in size will result in an <code>error</code>.</p> <pre><code>fun box ext_32(\n  b: Writer ref,\n  t: U8 val,\n  v: (String val | Array[U8 val] val))\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_47","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>t: U8 val</li> <li>v: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_48","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp_32","title":"timestamp_32","text":"<p>[Source]</p> <p>timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in a 32-bit unsigned integer.</p> <p>It can represent a timestamp in [1970-01-01 00:00:00 UTC, 2106-02-07 06:28:16 UTC).</p> <p>Nanoseconds part is 0.</p> <pre><code>fun box timestamp_32(\n  b: Writer ref,\n  sec: U32 val)\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_48","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_49","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp_64","title":"timestamp_64","text":"<p>[Source]</p> <p>timestamp 64 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers.</p> <p>It can represent a timestamp in [1970-01-01 00:00:00.000000000 UTC, 2514-05-30 01:53:04.000000000 UTC).</p> <p><code>nsec</code> must not be larger than 999999999. <code>sec</code> must not be larger than (2^34 - 1).</p> <pre><code>fun box timestamp_64(\n  b: Writer ref,\n  sec: U64 val,\n  nsec: U32 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_49","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: U64 val</li> <li>nsec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_50","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#timestamp_96","title":"timestamp_96","text":"<p>[Source]</p> <p>timestamp 96 stores the number of seconds and nanoseconds that have elapsed since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer.</p> <p>It can represent a timestamp in [-584554047284-02-23 16:59:44 UTC, 584554051223-11-09 07:00:16.000000000 UTC).</p> <p><code>nsec</code> must not be larger than 999999999.</p> <pre><code>fun box timestamp_96(\n  b: Writer ref,\n  sec: I64 val,\n  nsec: U32 val)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_50","title":"Parameters","text":"<ul> <li>b: Writer ref</li> <li>sec: I64 val</li> <li>nsec: U32 val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_51","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: MessagePackEncoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_51","title":"Parameters","text":"<ul> <li>that: MessagePackEncoder val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_52","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: MessagePackEncoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackEncoder/#parameters_52","title":"Parameters","text":"<ul> <li>that: MessagePackEncoder val</li> </ul>"},{"location":"msgpack-MessagePackEncoder/#returns_53","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackExt/","title":"MessagePackExt","text":"<p>[Source]</p> <p>A MessagePack extension type. The <code>ext_type</code> field is the type identifier stored as a <code>U8</code>. User-defined types occupy 0 through 127. The MessagePack spec reserves -1 through -128 (signed) for predefined types (e.g., -1 for timestamps); these appear in <code>ext_type</code> as their unsigned equivalents (0xFF for -1, 0x80 for -128). The <code>data</code> field contains the raw extension bytes.</p> <pre><code>class val MessagePackExt\n</code></pre>"},{"location":"msgpack-MessagePackExt/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackExt/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  ext_type': U8 val,\n  data': Array[U8 val] val)\n: MessagePackExt val^\n</code></pre>"},{"location":"msgpack-MessagePackExt/#parameters","title":"Parameters","text":"<ul> <li>ext_type': U8 val</li> <li>data': Array[U8 val] val</li> </ul>"},{"location":"msgpack-MessagePackExt/#returns","title":"Returns","text":"<ul> <li>MessagePackExt val^</li> </ul>"},{"location":"msgpack-MessagePackExt/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackExt/#let-ext_type-u8-val","title":"let ext_type: U8 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackExt/#let-data-arrayu8-val-val","title":"let data: Array[U8 val] val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackMap/","title":"MessagePackMap","text":"<p>[Source]</p> <p>Header for a MessagePack map. The <code>size</code> field indicates how many key-value pairs follow. The caller is responsible for reading <code>size * 2</code> subsequent values (alternating keys and values).</p> <pre><code>class val MessagePackMap\n</code></pre>"},{"location":"msgpack-MessagePackMap/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackMap/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  size': U32 val)\n: MessagePackMap val^\n</code></pre>"},{"location":"msgpack-MessagePackMap/#parameters","title":"Parameters","text":"<ul> <li>size': U32 val</li> </ul>"},{"location":"msgpack-MessagePackMap/#returns","title":"Returns","text":"<ul> <li>MessagePackMap val^</li> </ul>"},{"location":"msgpack-MessagePackMap/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackMap/#let-size-u32-val","title":"let size: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackStreamingDecoder/","title":"MessagePackStreamingDecoder","text":"<p>[Source]</p> <p>A streaming-safe MessagePack decoder that never corrupts the underlying reader on insufficient data.</p> <p>Unlike <code>MessagePackDecoder</code>, which assumes all data is available and will corrupt the reader's state on partial reads, this class peeks at the format byte and any length fields before consuming any bytes. If insufficient data is available, it returns <code>NotEnoughData</code> with zero bytes consumed, allowing the caller to append more data and retry.</p> <p>Limits protect against denial-of-service attacks where a malicious payload claims enormous sizes for variable-length values or deeply nested containers. By default, conservative limits are applied (1 MB for str/bin/ext, 131,072 for array/map counts, 512 for container nesting depth). When a value exceeds its limit, <code>next()</code> returns <code>LimitExceeded</code> with zero bytes consumed.</p> <p>The decoder automatically tracks container nesting depth. When <code>next()</code> returns a <code>MessagePackArray</code> or <code>MessagePackMap</code>, the depth counter increments. As the caller reads elements and containers are exhausted, the depth counter decrements automatically. Use <code>depth()</code> to inspect the current nesting level.</p> <p>When <code>validate_utf8</code> is <code>true</code>, decoded str values are validated for UTF-8 correctness. If a str value contains invalid UTF-8 byte sequences, <code>next()</code> returns <code>InvalidUtf8</code> instead of the decoded string. The bytes have been consumed from the reader and decoding can continue. By default, validation is off for backward compatibility.</p> <p>Usage: <pre><code>// Default conservative limits, no UTF-8 validation:\nlet decoder = MessagePackStreamingDecoder\ndecoder.append(chunk1)\nmatch decoder.next()\n| let v: U32 =&gt; // got a value\n| NotEnoughData =&gt; // need more data, append and retry\n| LimitExceeded =&gt; // value too large or too deep, reject\n| InvalidData =&gt; // corrupt stream, abort\nend\n\n// Custom limits:\nlet limits = MessagePackDecodeLimits(\n  where max_str_len' = 4096,\n        max_depth' = 16)\nlet decoder = MessagePackStreamingDecoder(limits)\n\n// With UTF-8 validation:\nlet decoder = MessagePackStreamingDecoder(\n  where validate_utf8' = true)\nmatch decoder.next()\n| InvalidUtf8 =&gt; // str value had invalid UTF-8\nend\n\n// No limits:\nlet decoder = MessagePackStreamingDecoder(\n  MessagePackDecodeLimits.unlimited())\n</code></pre></p> <p>Container types (arrays and maps) return header objects (<code>MessagePackArray</code> / <code>MessagePackMap</code>) containing the element count. The caller is responsible for subsequently reading that many values.</p> <pre><code>class ref MessagePackStreamingDecoder\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackStreamingDecoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new ref create(\n  limits: MessagePackDecodeLimits val = reference,\n  validate_utf8': Bool val = false)\n: MessagePackStreamingDecoder ref^\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#parameters","title":"Parameters","text":"<ul> <li>limits: MessagePackDecodeLimits val = reference</li> <li>validate_utf8': Bool val = false</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns","title":"Returns","text":"<ul> <li>MessagePackStreamingDecoder ref^</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackStreamingDecoder/#append","title":"append","text":"<p>[Source]</p> <p>Append data to the internal reader. Call this as chunks arrive.</p> <pre><code>fun ref append(\n  data: (String val | Array[U8 val] val))\n: None val\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#parameters_1","title":"Parameters","text":"<ul> <li>data: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns_1","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#depth","title":"depth","text":"<p>[Source]</p> <p>Returns the current container nesting depth. Depth increases when <code>next()</code> returns <code>MessagePackArray</code> or <code>MessagePackMap</code>, and decreases automatically as elements are consumed.</p> <pre><code>fun box depth()\n: USize val\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns_2","title":"Returns","text":"<ul> <li>USize val</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#next","title":"next","text":"<p>[Source]</p> <p>Attempt to decode the next MessagePack value.</p> <p>Returns one of: - A <code>MessagePackValue</code> if a complete value was decoded - <code>NotEnoughData</code> if more bytes are needed (no bytes consumed) - <code>LimitExceeded</code> if the value exceeds a configured size   limit (no bytes consumed) - <code>InvalidData</code> if the format byte is invalid (0xC1).   The invalid byte is NOT consumed. The caller must stop   calling <code>next()</code> after receiving <code>InvalidData</code> \u2014 the   stream is corrupt and cannot be resynced.</p> <pre><code>fun ref next()\n: (None val | Bool val | U8 val | \n    U16 val | U32 val | U64 val | \n    I8 val | I16 val | I32 val | \n    I64 val | F32 val | F64 val | \n    String val | Array[U8 val] val | MessagePackArray val | \n    MessagePackMap val | MessagePackExt val | MessagePackTimestamp val | \n    NotEnoughData val | InvalidData val | InvalidUtf8 val | \n    LimitExceeded val)\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns_3","title":"Returns","text":"<ul> <li>(None val | Bool val | U8 val |      U16 val | U32 val | U64 val |      I8 val | I16 val | I32 val |      I64 val | F32 val | F64 val |      String val | Array[U8 val] val | MessagePackArray val |      MessagePackMap val | MessagePackExt val | MessagePackTimestamp val |      NotEnoughData val | InvalidData val | InvalidUtf8 val |      LimitExceeded val)</li> </ul>"},{"location":"msgpack-MessagePackStreamingDecoder/#skip","title":"skip","text":"<p>[Source]</p> <p>Advances past one complete MessagePack value without decoding it. For containers (arrays and maps), skips all contained elements.</p> <p>Returns <code>None</code> on success, <code>NotEnoughData</code> if more bytes are needed (no bytes consumed), <code>InvalidData</code> if the format byte is invalid (no bytes consumed), or <code>LimitExceeded</code> if the number of values traversed exceeds the configured <code>max_skip_values</code> limit (no bytes consumed).</p> <p>Like <code>next()</code>, a successful skip decrements the parent container's remaining element count when called inside a container.</p> <pre><code>fun ref skip()\n: (None val | NotEnoughData val | InvalidData val | \n    LimitExceeded val)\n</code></pre>"},{"location":"msgpack-MessagePackStreamingDecoder/#returns_4","title":"Returns","text":"<ul> <li>(None val | NotEnoughData val | InvalidData val |      LimitExceeded val)</li> </ul>"},{"location":"msgpack-MessagePackTimestamp/","title":"MessagePackTimestamp","text":"<p>[Source]</p> <p>A decoded MessagePack timestamp. The <code>sec</code> field is the number of seconds since 1970-01-01 00:00:00 UTC (can be negative for dates before the epoch). The <code>nsec</code> field is the nanoseconds component (0 to 999999999).</p> <pre><code>class val MessagePackTimestamp\n</code></pre>"},{"location":"msgpack-MessagePackTimestamp/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackTimestamp/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create(\n  sec': I64 val,\n  nsec': U32 val)\n: MessagePackTimestamp val^\n</code></pre>"},{"location":"msgpack-MessagePackTimestamp/#parameters","title":"Parameters","text":"<ul> <li>sec': I64 val</li> <li>nsec': U32 val</li> </ul>"},{"location":"msgpack-MessagePackTimestamp/#returns","title":"Returns","text":"<ul> <li>MessagePackTimestamp val^</li> </ul>"},{"location":"msgpack-MessagePackTimestamp/#public-fields","title":"Public fields","text":""},{"location":"msgpack-MessagePackTimestamp/#let-sec-i64-val","title":"let sec: I64 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackTimestamp/#let-nsec-u32-val","title":"let nsec: U32 val","text":"<p>[Source]</p>"},{"location":"msgpack-MessagePackType/","title":"MessagePackType","text":"<p>[Source] <pre><code>type MessagePackType is\n  U8 val\n</code></pre></p>"},{"location":"msgpack-MessagePackType/#type-alias-for","title":"Type Alias For","text":"<ul> <li>U8 val</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/","title":"MessagePackValidateUTF8","text":"<p>[Source]</p> <p>Validates whether a string contains only valid UTF-8 byte sequences. Returns <code>true</code> if the string is valid UTF-8, <code>false</code> otherwise.</p> <p>This is useful in the \"decode then validate\" pattern, where callers decode a string using a non-validating method and then validate separately so they retain access to the raw bytes on failure:</p> <pre><code>let s = MessagePackDecoder.str(reader)?\n\nif not MessagePackValidateUTF8(s) then\n  // s still available \u2014 log, reject, or treat as raw bytes\nend\n</code></pre> <pre><code>primitive val MessagePackValidateUTF8\n</code></pre>"},{"location":"msgpack-MessagePackValidateUTF8/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackValidateUTF8/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: MessagePackValidateUTF8 val^\n</code></pre>"},{"location":"msgpack-MessagePackValidateUTF8/#returns","title":"Returns","text":"<ul> <li>MessagePackValidateUTF8 val^</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackValidateUTF8/#apply","title":"apply","text":"<p>[Source]</p> <pre><code>fun box apply(\n  s: String box)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackValidateUTF8/#parameters","title":"Parameters","text":"<ul> <li>s: String box</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: MessagePackValidateUTF8 val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackValidateUTF8/#parameters_1","title":"Parameters","text":"<ul> <li>that: MessagePackValidateUTF8 val</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: MessagePackValidateUTF8 val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackValidateUTF8/#parameters_2","title":"Parameters","text":"<ul> <li>that: MessagePackValidateUTF8 val</li> </ul>"},{"location":"msgpack-MessagePackValidateUTF8/#returns_3","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackValue/","title":"MessagePackValue","text":"<p>[Source] <pre><code>type MessagePackValue is\n  (None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val)\n</code></pre></p>"},{"location":"msgpack-MessagePackValue/#type-alias-for","title":"Type Alias For","text":"<ul> <li>(None val | Bool val | U8 val | U16 val | U32 val | U64 val | I8 val | I16 val | I32 val | I64 val | F32 val | F64 val | String val | Array[U8 val] val | MessagePackArray val | MessagePackMap val | MessagePackExt val | MessagePackTimestamp val)</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/","title":"MessagePackZeroCopyDecoder","text":"<p>[Source]</p> <p>Implements low-level zero-copy decoding from the MessagePack serialization format.</p> <p>This decoder mirrors <code>MessagePackDecoder</code> but takes a <code>ZeroCopyReader</code> instead of a <code>buffered.Reader</code>. Variable-length values (strings, binary data, extensions) are returned as <code>val</code> views into the reader's internal buffer rather than freshly allocated copies. Fixed-size values (integers, floats, booleans) are decoded identically to <code>MessagePackDecoder</code>.</p> <p>You should be familiar with how MessagePack encodes messages if you use this API directly. There are very few guardrails preventing you from incorrectly decoding documents. This is particularly true when using the <code>array</code> and <code>map</code> format family decoding methods, which only read headers \u2014 the caller must read each element individually afterward.</p> <p>Two styles of decode methods are provided:</p> <ul> <li>Compact methods (<code>uint</code>, <code>int</code>, <code>str</code>, <code>byte_array</code>, <code>ext</code>,   <code>array</code>, <code>map</code>) peek at the format byte to determine the wire   format and accept any format within the family.</li> <li>Format-specific methods (<code>u8</code>, <code>u16</code>, <code>str_8</code>, <code>str_16</code>,   <code>bin_8</code>, <code>fixext_1</code>, <code>ext_8</code>, etc.) validate a single expected   format byte, then read the data directly. Use these when you   know the exact wire format in advance.</li> </ul> <p>This decoder assumes all data is available when decoding begins. For streaming use, <code>MessagePackStreamingDecoder</code> uses zero-copy decoding internally.</p> <pre><code>primitive val MessagePackZeroCopyDecoder\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#constructors","title":"Constructors","text":""},{"location":"msgpack-MessagePackZeroCopyDecoder/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: MessagePackZeroCopyDecoder val^\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns","title":"Returns","text":"<ul> <li>MessagePackZeroCopyDecoder val^</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-MessagePackZeroCopyDecoder/#uint","title":"uint","text":"<p>[Source]</p> <p>Decodes an unsigned integer from any uint or positive fixint format.</p> <pre><code>fun box uint(\n  b: ZeroCopyReader ref)\n: U64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_1","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#int","title":"int","text":"<p>[Source]</p> <p>Decodes a signed integer from any int, uint, or fixint format. Errors if a uint_64 value exceeds I64.max_value().</p> <pre><code>fun box int(\n  b: ZeroCopyReader ref)\n: I64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_1","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_2","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#array","title":"array","text":"<p>[Source]</p> <p>Reads an array header from any array format. Returns the element count. The caller must read that many elements afterward.</p> <pre><code>fun box array(\n  b: ZeroCopyReader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_2","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_3","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#map","title":"map","text":"<p>[Source]</p> <p>Reads a map header from any map format. Returns the pair count. The caller must read that many key-value pairs afterward.</p> <pre><code>fun box map(\n  b: ZeroCopyReader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_3","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_4","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#nil","title":"nil","text":"<p>[Source]</p> <p>Returns nothing. Throws an error if the next byte isn't a MessagePack nil.</p> <pre><code>fun box nil(\n  b: ZeroCopyReader ref)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_4","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_5","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#bool","title":"bool","text":"<p>[Source]</p> <pre><code>fun box bool(\n  b: ZeroCopyReader ref)\n: Bool val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_5","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_6","title":"Returns","text":"<ul> <li>Bool val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#positive_fixint","title":"positive_fixint","text":"<p>[Source]</p> <pre><code>fun box positive_fixint(\n  b: ZeroCopyReader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_6","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_7","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#negative_fixint","title":"negative_fixint","text":"<p>[Source]</p> <pre><code>fun box negative_fixint(\n  b: ZeroCopyReader ref)\n: I8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_7","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_8","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#u8","title":"u8","text":"<p>[Source]</p> <pre><code>fun box u8(\n  b: ZeroCopyReader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_8","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_9","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#u16","title":"u16","text":"<p>[Source]</p> <pre><code>fun box u16(\n  b: ZeroCopyReader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_9","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_10","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#u32","title":"u32","text":"<p>[Source]</p> <pre><code>fun box u32(\n  b: ZeroCopyReader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_10","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_11","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#u64","title":"u64","text":"<p>[Source]</p> <pre><code>fun box u64(\n  b: ZeroCopyReader ref)\n: U64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_11","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_12","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#i8","title":"i8","text":"<p>[Source]</p> <pre><code>fun box i8(\n  b: ZeroCopyReader ref)\n: I8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_12","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_13","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#i16","title":"i16","text":"<p>[Source]</p> <pre><code>fun box i16(\n  b: ZeroCopyReader ref)\n: I16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_13","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_14","title":"Returns","text":"<ul> <li>I16 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#i32","title":"i32","text":"<p>[Source]</p> <pre><code>fun box i32(\n  b: ZeroCopyReader ref)\n: I32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_14","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_15","title":"Returns","text":"<ul> <li>I32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#i64","title":"i64","text":"<p>[Source]</p> <pre><code>fun box i64(\n  b: ZeroCopyReader ref)\n: I64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_15","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_16","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#f32","title":"f32","text":"<p>[Source]</p> <pre><code>fun box f32(\n  b: ZeroCopyReader ref)\n: F32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_16","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_17","title":"Returns","text":"<ul> <li>F32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#f64","title":"f64","text":"<p>[Source]</p> <pre><code>fun box f64(\n  b: ZeroCopyReader ref)\n: F64 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_17","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_18","title":"Returns","text":"<ul> <li>F64 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixstr","title":"fixstr","text":"<p>[Source]</p> <pre><code>fun box fixstr(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_18","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_19","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str","title":"str","text":"<p>[Source]</p> <pre><code>fun box str(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_19","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_20","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_8","title":"str_8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 8 value. Validates that the format byte is str_8 (0xD9), then reads the 1-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_8(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_20","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_21","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_16","title":"str_16","text":"<p>[Source]</p> <p>Decodes a MessagePack str 16 value. Validates that the format byte is str_16 (0xDA), then reads the 2-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_16(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_21","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_22","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_32","title":"str_32","text":"<p>[Source]</p> <p>Decodes a MessagePack str 32 value. Validates that the format byte is str_32 (0xDB), then reads the 4-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any string wire format, use <code>str()</code> instead.</p> <pre><code>fun box str_32(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_22","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_23","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_utf8","title":"str_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str value using the smallest matching format, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte is not a str type, if insufficient data is available, or if the decoded bytes are not valid UTF-8. On a UTF-8 validation error the bytes have already been consumed from the reader. For the non-validating variant, use <code>str()</code>. To retain access to the raw bytes on validation failure, use <code>str()</code> followed by <code>MessagePackValidateUTF8</code>.</p> <pre><code>fun box str_utf8(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_23","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_24","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixstr_utf8","title":"fixstr_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack fixstr value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>fixstr()</code>.</p> <pre><code>fun box fixstr_utf8(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_24","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_25","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_8_utf8","title":"str_8_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 8 value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>str_8()</code>.</p> <pre><code>fun box str_8_utf8(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_25","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_26","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_16_utf8","title":"str_16_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 16 value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>str_16()</code>.</p> <pre><code>fun box str_16_utf8(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_26","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_27","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#str_32_utf8","title":"str_32_utf8","text":"<p>[Source]</p> <p>Decodes a MessagePack str 32 value, then validates that the bytes are valid UTF-8.</p> <p>Errors if the format byte does not match, if insufficient data is available, or if the decoded bytes are not valid UTF-8. For the non-validating variant, use <code>str_32()</code>.</p> <pre><code>fun box str_32_utf8(\n  b: ZeroCopyReader ref)\n: String val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_27","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_28","title":"Returns","text":"<ul> <li>String val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#byte_array","title":"byte_array","text":"<p>[Source]</p> <pre><code>fun box byte_array(\n  b: ZeroCopyReader ref)\n: Array[U8 val] val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_28","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_29","title":"Returns","text":"<ul> <li>Array[U8 val] val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#bin_8","title":"bin_8","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 8 value. Validates that the format byte is bin_8 (0xC4), then reads the 1-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_8(\n  b: ZeroCopyReader ref)\n: Array[U8 val] val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_29","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_30","title":"Returns","text":"<ul> <li>Array[U8 val] val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#bin_16","title":"bin_16","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 16 value. Validates that the format byte is bin_16 (0xC5), then reads the 2-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_16(\n  b: ZeroCopyReader ref)\n: Array[U8 val] val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_30","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_31","title":"Returns","text":"<ul> <li>Array[U8 val] val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#bin_32","title":"bin_32","text":"<p>[Source]</p> <p>Decodes a MessagePack bin 32 value. Validates that the format byte is bin_32 (0xC6), then reads the 4-byte length prefix and data.</p> <p>Errors if the format byte does not match or if insufficient data is available. For a method that accepts any bin wire format, use <code>byte_array()</code> instead.</p> <pre><code>fun box bin_32(\n  b: ZeroCopyReader ref)\n: Array[U8 val] val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_31","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_32","title":"Returns","text":"<ul> <li>Array[U8 val] val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixarray","title":"fixarray","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"fixarray\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box fixarray(\n  b: ZeroCopyReader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_32","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_33","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#array_16","title":"array_16","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"array_16\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box array_16(\n  b: ZeroCopyReader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_33","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_34","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#array_32","title":"array_32","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"array_32\". This only reads the header. The number of array items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box array_32(\n  b: ZeroCopyReader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_34","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_35","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixmap","title":"fixmap","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"fixmap\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box fixmap(\n  b: ZeroCopyReader ref)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_35","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_36","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#map_16","title":"map_16","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"map_16\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box map_16(\n  b: ZeroCopyReader ref)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_36","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_37","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#map_32","title":"map_32","text":"<p>[Source]</p> <p>Reads a header for a MessgePack \"map_32\". This only reads the header. The number of map items returned by this method needs to be read via other methods after this is called.</p> <pre><code>fun box map_32(\n  b: ZeroCopyReader ref)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_37","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_38","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#ext","title":"ext","text":"<p>[Source]</p> <p>Allows for the reading of user supplied extensions to the MessagePack format.</p> <p>fixext * types return a tuple representing:</p> <p>(user supplied type indentifier, data byte array)</p> <pre><code>fun box ext(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_38","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_39","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixext_1","title":"fixext_1","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 1 value. Validates that the format byte is fixext_1 (0xD4), then reads the ext type byte and 1 byte of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_1(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_39","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_40","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixext_2","title":"fixext_2","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 2 value. Validates that the format byte is fixext_2 (0xD5), then reads the ext type byte and 2 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_2(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_40","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_41","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixext_4","title":"fixext_4","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 4 value. Validates that the format byte is fixext_4 (0xD6), then reads the ext type byte and 4 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_4(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_41","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_42","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixext_8","title":"fixext_8","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 8 value. Validates that the format byte is fixext_8 (0xD7), then reads the ext type byte and 8 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_8(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_42","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_43","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#fixext_16","title":"fixext_16","text":"<p>[Source]</p> <p>Decodes a MessagePack fixext 16 value. Validates that the format byte is fixext_16 (0xD8), then reads the ext type byte and 16 bytes of data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box fixext_16(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_43","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_44","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#ext_8","title":"ext_8","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 8 value. Validates that the format byte is ext_8 (0xC7), then reads the 1-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_8(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_44","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_45","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#ext_16","title":"ext_16","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 16 value. Validates that the format byte is ext_16 (0xC8), then reads the 2-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_16(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_45","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_46","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#ext_32","title":"ext_32","text":"<p>[Source]</p> <p>Decodes a MessagePack ext 32 value. Validates that the format byte is ext_32 (0xC9), then reads the 4-byte length prefix, ext type byte, and data.</p> <p>Returns <code>(ext_type, data)</code>. Errors if the format byte does not match. For a method that accepts any ext wire format, use <code>ext()</code> instead.</p> <pre><code>fun box ext_32(\n  b: ZeroCopyReader ref)\n: (U8 val , Array[U8 val] val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_46","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_47","title":"Returns","text":"<ul> <li>(U8 val , Array[U8 val] val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#timestamp","title":"timestamp","text":"<p>[Source]</p> <pre><code>fun box timestamp(\n  b: ZeroCopyReader ref)\n: (I64 val , U32 val) ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_47","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_48","title":"Returns","text":"<ul> <li>(I64 val , U32 val) ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#skip","title":"skip","text":"<p>[Source]</p> <p>Advances past one complete MessagePack value without decoding it. For containers (arrays and maps), skips all contained elements.</p> <p>Errors if insufficient data is available or if the format byte is invalid (0xC1). On error, no bytes are consumed.</p> <p>This method has no limit on the number of values traversed. For protection against container amplification attacks, use <code>MessagePackStreamingDecoder.skip</code> which enforces a configurable <code>max_skip_values</code> limit.</p> <pre><code>fun box skip(\n  b: ZeroCopyReader ref)\n: None val ?\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_48","title":"Parameters","text":"<ul> <li>b: ZeroCopyReader ref</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_49","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: MessagePackZeroCopyDecoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_49","title":"Parameters","text":"<ul> <li>that: MessagePackZeroCopyDecoder val</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_50","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: MessagePackZeroCopyDecoder val)\n: Bool val\n</code></pre>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#parameters_50","title":"Parameters","text":"<ul> <li>that: MessagePackZeroCopyDecoder val</li> </ul>"},{"location":"msgpack-MessagePackZeroCopyDecoder/#returns_51","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-NotEnoughData/","title":"NotEnoughData","text":"<p>[Source]</p> <p>Returned when the reader doesn't have enough data to decode the next value. The caller should append more data and retry. No bytes have been consumed from the reader.</p> <pre><code>primitive val NotEnoughData\n</code></pre>"},{"location":"msgpack-NotEnoughData/#constructors","title":"Constructors","text":""},{"location":"msgpack-NotEnoughData/#create","title":"create","text":"<p>[Source]</p> <pre><code>new val create()\n: NotEnoughData val^\n</code></pre>"},{"location":"msgpack-NotEnoughData/#returns","title":"Returns","text":"<ul> <li>NotEnoughData val^</li> </ul>"},{"location":"msgpack-NotEnoughData/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-NotEnoughData/#eq","title":"eq","text":"<p>[Source]</p> <pre><code>fun box eq(\n  that: NotEnoughData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-NotEnoughData/#parameters","title":"Parameters","text":"<ul> <li>that: NotEnoughData val</li> </ul>"},{"location":"msgpack-NotEnoughData/#returns_1","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-NotEnoughData/#ne","title":"ne","text":"<p>[Source]</p> <pre><code>fun box ne(\n  that: NotEnoughData val)\n: Bool val\n</code></pre>"},{"location":"msgpack-NotEnoughData/#parameters_1","title":"Parameters","text":"<ul> <li>that: NotEnoughData val</li> </ul>"},{"location":"msgpack-NotEnoughData/#returns_2","title":"Returns","text":"<ul> <li>Bool val</li> </ul>"},{"location":"msgpack-SkipResult/","title":"SkipResult","text":"<p>[Source] <pre><code>type SkipResult is\n  (None val | NotEnoughData val | InvalidData val | LimitExceeded val)\n</code></pre></p>"},{"location":"msgpack-SkipResult/#type-alias-for","title":"Type Alias For","text":"<ul> <li>(None val | NotEnoughData val | InvalidData val | LimitExceeded val)</li> </ul>"},{"location":"msgpack-ZeroCopyReader/","title":"ZeroCopyReader","text":"<p>[Source]</p> <p>A reader optimized for zero-copy extraction of byte ranges. Returns <code>val</code> views into the internal buffer instead of copying into fresh <code>iso</code> arrays.</p> <p>Zero-copy succeeds when the requested range falls within a single internal chunk. When data spans chunk boundaries, the reader falls back to copying \u2014 no worse than <code>buffered.Reader</code>.</p> <p>This reader is specific to the msgpack package and is not interoperable with APIs that expect <code>buffered.Reader</code>. Use it with <code>MessagePackZeroCopyDecoder</code> for zero-copy decoding, or use <code>MessagePackStreamingDecoder</code> which uses it internally.</p> <p>Decoded values returned via <code>block()</code> may hold references to the reader's internal chunks. As long as a decoded value is live, its source chunk stays in memory. For most use cases (decode, process, discard) this is not a concern. Callers who cache decoded values should be aware of this lifetime relationship.</p> <pre><code>class ref ZeroCopyReader\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#constructors","title":"Constructors","text":""},{"location":"msgpack-ZeroCopyReader/#create","title":"create","text":"<p>[Source]</p> <pre><code>new ref create()\n: ZeroCopyReader ref^\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns","title":"Returns","text":"<ul> <li>ZeroCopyReader ref^</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#public-functions","title":"Public Functions","text":""},{"location":"msgpack-ZeroCopyReader/#size","title":"size","text":"<p>[Source]</p> <p>Return the number of available bytes.</p> <pre><code>fun box size()\n: USize val\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_1","title":"Returns","text":"<ul> <li>USize val</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#append","title":"append","text":"<p>[Source]</p> <p>Add a chunk of data. The reader holds a <code>val</code> reference to the chunk's underlying array. No copy is performed.</p> <pre><code>fun ref append(\n  data: (String val | Array[U8 val] val))\n: None val\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#parameters","title":"Parameters","text":"<ul> <li>data: (String val | Array[U8 val] val)</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#returns_2","title":"Returns","text":"<ul> <li>None val</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#block","title":"block","text":"<p>[Source]</p> <p>Return <code>len</code> bytes. If the range falls within a single chunk, returns a <code>trim</code>'d view (zero-copy). If it spans chunks, copies into a new array (fallback).</p> <pre><code>fun ref block(\n  len: USize val)\n: Array[U8 val] val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#parameters_1","title":"Parameters","text":"<ul> <li>len: USize val</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#returns_3","title":"Returns","text":"<ul> <li>Array[U8 val] val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#skip","title":"skip","text":"<p>[Source]</p> <p>Skip <code>n</code> bytes. Errors if fewer than <code>n</code> bytes are available.</p> <pre><code>fun ref skip(\n  n: USize val)\n: None val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#parameters_2","title":"Parameters","text":"<ul> <li>n: USize val</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#returns_4","title":"Returns","text":"<ul> <li>None val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#u8","title":"u8","text":"<p>[Source]</p> <p>Get a U8. Errors if there isn't enough data.</p> <pre><code>fun ref u8()\n: U8 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_5","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#i8","title":"i8","text":"<p>[Source]</p> <p>Get an I8.</p> <pre><code>fun ref i8()\n: I8 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_6","title":"Returns","text":"<ul> <li>I8 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#u16_be","title":"u16_be","text":"<p>[Source]</p> <p>Get a big-endian U16.</p> <pre><code>fun ref u16_be()\n: U16 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_7","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#i16_be","title":"i16_be","text":"<p>[Source]</p> <p>Get a big-endian I16.</p> <pre><code>fun ref i16_be()\n: I16 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_8","title":"Returns","text":"<ul> <li>I16 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#u32_be","title":"u32_be","text":"<p>[Source]</p> <p>Get a big-endian U32.</p> <pre><code>fun ref u32_be()\n: U32 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_9","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#i32_be","title":"i32_be","text":"<p>[Source]</p> <p>Get a big-endian I32.</p> <pre><code>fun ref i32_be()\n: I32 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_10","title":"Returns","text":"<ul> <li>I32 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#u64_be","title":"u64_be","text":"<p>[Source]</p> <p>Get a big-endian U64.</p> <pre><code>fun ref u64_be()\n: U64 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_11","title":"Returns","text":"<ul> <li>U64 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#i64_be","title":"i64_be","text":"<p>[Source]</p> <p>Get a big-endian I64.</p> <pre><code>fun ref i64_be()\n: I64 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_12","title":"Returns","text":"<ul> <li>I64 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#f32_be","title":"f32_be","text":"<p>[Source]</p> <p>Get a big-endian F32.</p> <pre><code>fun ref f32_be()\n: F32 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_13","title":"Returns","text":"<ul> <li>F32 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#f64_be","title":"f64_be","text":"<p>[Source]</p> <p>Get a big-endian F64.</p> <pre><code>fun ref f64_be()\n: F64 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#returns_14","title":"Returns","text":"<ul> <li>F64 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#peek_u8","title":"peek_u8","text":"<p>[Source]</p> <p>Peek at a U8 at the given offset without consuming it. Errors if there isn't enough data.</p> <pre><code>fun box peek_u8(\n  offset: USize val = 0)\n: U8 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#parameters_3","title":"Parameters","text":"<ul> <li>offset: USize val = 0</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#returns_15","title":"Returns","text":"<ul> <li>U8 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#peek_u16_be","title":"peek_u16_be","text":"<p>[Source]</p> <p>Peek at a big-endian U16 at the given offset without consuming it.</p> <pre><code>fun box peek_u16_be(\n  offset: USize val = 0)\n: U16 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#parameters_4","title":"Parameters","text":"<ul> <li>offset: USize val = 0</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#returns_16","title":"Returns","text":"<ul> <li>U16 val ?</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#peek_u32_be","title":"peek_u32_be","text":"<p>[Source]</p> <p>Peek at a big-endian U32 at the given offset without consuming it.</p> <pre><code>fun box peek_u32_be(\n  offset: USize val = 0)\n: U32 val ?\n</code></pre>"},{"location":"msgpack-ZeroCopyReader/#parameters_5","title":"Parameters","text":"<ul> <li>offset: USize val = 0</li> </ul>"},{"location":"msgpack-ZeroCopyReader/#returns_17","title":"Returns","text":"<ul> <li>U32 val ?</li> </ul>"}]}