



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://seantallen-org.github.io/msgpack/src/msgpack/message_pack_encoder/">
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../../assets/images/logo.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-ponylang-0.2.8">
    
    
      
        <title>Message pack encoder - msgpack</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/application.b80b25f7.css">
      
    
    
      <script src="../../../assets/javascripts/modernizr.0b5df86e.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
          <a href="https://seantallen-org.github.io/msgpack/" title="msgpack" class="md-header-nav__button md-logo">
          
            <img src="../../../assets/images/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                msgpack
              </span>
              <span class="md-header-nav__topic">
                Message pack encoder
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <span class="md-nav__button md-logo">
      
        <img src="../../../assets/images/logo.png" width="48" height="48">
      
    </span>
    msgpack
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../.." title="msgpack" class="md-nav__link">
      msgpack
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      package msgpack
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        package msgpack
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../msgpack--index/" title="Package" class="md-nav__link">
      Package
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../msgpack-MessagePackEncoder/" title="primitive MessagePackEncoder" class="md-nav__link">
      primitive MessagePackEncoder
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../msgpack-MessagePackType/" title="type MessagePackType" class="md-nav__link">
      type MessagePackType
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../msgpack-MessagePackDecoder/" title="primitive MessagePackDecoder" class="md-nav__link">
      primitive MessagePackDecoder
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../msgpack-Main/" title="actor Main" class="md-nav__link">
      actor Main
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>Message pack encoder</h1>
                
                <pre><code class="language-pony-full-source">/*

Copyright 2017 The Pony MessagePack Developers

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

use &quot;buffered&quot;

primitive MessagePackEncoder
  &quot;&quot;&quot;
  Implements low-level encoding into the [MessagePack serialization format](https://github.com/msgpack/msgpack/blob/master/spec.md).

  You should be familiar with how MessagePack encodes messages if you use this
  API directly. There are very few guardrails preventing you from creating
  invalid documents. This is particularly true when using the `array` and `map`
  format family encoding methods.
  &quot;&quot;&quot;
  //
  // nil format family
  //

  fun nil(b: Writer) =&gt;
    &quot;&quot;&quot;
    nil format stores nil in 1 byte.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.nil())

  //
  // bool format family
  //

  fun bool(b: Writer, t_or_f: Bool) =&gt;
    &quot;&quot;&quot;
    bool format family stores false or true in 1 byte.
    &quot;&quot;&quot;
    if t_or_f then
      _write_type(b, _FormatName.truthy())
    else
      _write_type(b, _FormatName.falsey())
    end

  //
  // int format family
  //

  fun positive_fixint(b: Writer, v: U8) ? =&gt;
    &quot;&quot;&quot;
    positive fixnum stores 7-bit positive integer.

    - Max value that can be encoded is `127`.

    Attemping to encode an out of range value will result in an `error`.
    &quot;&quot;&quot;
    if v &lt;= _Limit.positive_fixint() then
      _write_fixed_value(b, v)
    else
      error
    end

  fun negative_fixint(b: Writer, v: I8) ? =&gt;
    &quot;&quot;&quot;
    negative fixnum stores 5-bit negative integer.

    - Max value that can be encoded is `-1`.
    - Min value that can be encoded is `-32`.

    Attemping to encode an out of range value will result in an `error`.
    &quot;&quot;&quot;
    if (v &gt;= _Limit.negative_fixint_low()) and
      (v &lt;= _Limit.negative_fixint_high())
    then
      _write_fixed_value(b, v.u8())
    else
      error
    end

  fun uint_8(b: Writer, v: U8) =&gt;
    &quot;&quot;&quot;
    uint 8 stores a 8-bit unsigned integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.uint_8())
    b.u8(v)

  fun uint_16(b: Writer, v: U16) =&gt;
    &quot;&quot;&quot;
    uint 16 stores a 16-bit big-endian unsigned integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.uint_16())
    b.u16_be(v)

  fun uint_32(b: Writer, v: U32) =&gt;
    &quot;&quot;&quot;
    uint 32 stores a 32-bit big-endian unsigned integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.uint_32())
    b.u32_be(v)

  fun uint_64(b: Writer, v: U64) =&gt;
    &quot;&quot;&quot;
    uint 64 stores a 64-bit big-endian unsigned integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.uint_64())
    b.u64_be(v)

  fun int_8(b: Writer, v: I8) =&gt;
    &quot;&quot;&quot;
    int 8 stores a 8-bit signed integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.int_8())
    b.u8(v.u8())

  fun int_16(b: Writer, v: I16) =&gt;
    &quot;&quot;&quot;
    int 16 stores a 16-bit big-endian signed integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.int_16())
    b.i16_be(v)

  fun int_32(b: Writer, v: I32) =&gt;
    &quot;&quot;&quot;
    int 32 stores a 32-bit big-endian signed integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.int_32())
    b.i32_be(v)

  fun int_64(b: Writer, v: I64) =&gt;
    &quot;&quot;&quot;
    int 64 stores a 64-bit big-endian signed integer.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.int_64())
    b.i64_be(v)

  //
  // float format family
  //

  fun float_32(b: Writer, v: F32) =&gt;
    &quot;&quot;&quot;
    float 32 stores a floating point number in IEEE 754 single precision
    floating point number format.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.float_32())
    b.f32_be(v)

  fun float_64(b: Writer, v: F64) =&gt;
    &quot;&quot;&quot;
    float 64 stores a floating point number in IEEE 754 double precision
    floating point number format.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.float_64())
    b.f64_be(v)

  //
  // str format family
  //

  fun fixstr(b: Writer, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    fixstr stores a byte array whose length is upto 31 bytes.

    Attempting to encode a `ByteSeq` larger than 31 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    if v.size() &lt;= _Limit.fixstr() then
      _write_type(b, (_FormatName.fixstr() or v.size().u8()))
      b.write(v)
    else
      error
    end

  fun str_8(b: Writer, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    str 8 stores a byte array whose length is upto (2^8)-1 bytes.

    Attempting to encode a `ByteSeq` larger than (2^8)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_byte_array_8(b, v, _FormatName.str_8())?

  fun str_16(b: Writer, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    str 16 stores a byte array whose length is upto (2^16)-1 bytes.

    Attempting to encode a `ByteSeq` larger than (2^16)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_byte_array_16(b, v, _FormatName.str_16())?

   fun str_32(b: Writer, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    str 32 stores a byte array whose length is upto (2^32)-1.

    Attempting to encode a `ByteSeq` larger than (2^32)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_byte_array_32(b, v, _FormatName.str_32())?

  //
  // bin format family
  //

  fun bin_8(b: Writer, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    bin 8 stores a byte array whose length is upto (2^8)-1 bytes.

    Attempting to encode a `ByteSeq` larger than (2^8)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_byte_array_8(b, v, _FormatName.bin_8())?

  fun bin_16(b: Writer, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    bin 16 stores a byte array whose length is upto (2^16)-1 bytes.

    Attempting to encode a `ByteSeq` larger than (2^16)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_byte_array_16(b, v, _FormatName.bin_16())?

   fun bin_32(b: Writer, v: ByteSeq) ? =&gt;
     &quot;&quot;&quot;
     bin 32 stores a byte array whose length is upto (2^32)-1 bytes.

     Attempting to encode a `ByteSeq` larger than (2^32)-1 bytes will result in
     an `error`.
     &quot;&quot;&quot;
    _write_byte_array_32(b, v, _FormatName.bin_32())?

  //
  // array format family
  //

  fun fixarray(b: Writer, s: U8) ? =&gt;
    &quot;&quot;&quot;
    Creates a header for a MessagePack &quot;fixarray&quot;. This only creates the
    header. `s` number of array items should be written via other methods
    after this is called.

    fixarray stores an array whose length is upto 15 elements.

    Attempting to encode a value larger than 15 will result in an `error`.
    &quot;&quot;&quot;
    if s &lt;= _Limit.fixarray() then
      _write_type(b, (_FormatName.fixarray() or s))
    else
      error
    end

  fun array_16(b: Writer, s: U16) =&gt;
    &quot;&quot;&quot;
    Creates a header for a MessagePack &quot;array_16&quot;. This only creates the
    header. `s` number of array items should be written via other methods
    after this is called.

    array 16 stores an array whose length is upto (2^16)-1 elements.

    Attempting to encode a value larger than (2^16)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.array_16())
    b.u16_be(s)

  fun array_32(b: Writer, s: U32) =&gt;
    &quot;&quot;&quot;
    Creates a header for a MessagePack &quot;array_32&quot;. This only creates the
    header. `s` number of array items should be written via other methods
    after this is called.

    array 32 stores an array whose length is upto (2^32)-1 elements.

    Attempting to encode a value larger than (2^32)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.array_32())
    b.u32_be(s)

  //
  // map format family
  //

  fun fixmap(b: Writer, s: U8) ? =&gt;
    &quot;&quot;&quot;
    Creates a header for a MessagePack &quot;fixmap&quot;. This only creates the
    header. `s` number of map items should be written via other methods
    after this is called.

    fixmap stores a map whose length is upto 15 elements.

    Attempting to encode a value larger than 15 will result in an `error`.
    &quot;&quot;&quot;
    if s &lt;= _Limit.fixmap() then
      _write_type(b, (_FormatName.fixmap() or s))
    else
      error
    end

  fun map_16(b: Writer, s: U16) =&gt;
    &quot;&quot;&quot;
    Creates a header for a MessagePack &quot;map_16&quot;. This only creates the
    header. `s` number of map items should be written via other methods
    after this is called.

    map 16 stores an array whose length is upto (2^16)-1 elements.

    Attempting to encode a value larger than (2^16)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.map_16())
    b.u16_be(s)

  fun map_32(b: Writer, s: U32) =&gt;
    &quot;&quot;&quot;
    Creates a header for a MessagePack &quot;map_32&quot;. This only creates the
    header. `s` number of map items should be written via other methods
    after this is called.

    map 32 stores an array whose length is upto (2^32)-1 elements.

    Attempting to encode a value larger than (2^32)-1 bytes will result in
    an `error`.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.map_32())
    b.u32_be(s)

  //
  // ext format family
  //

  fun fixext_1(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    fixext 1 stores an integer and a byte array whose length is 1 byte.

    Attempting to encode a `ByteSeq` that is not 1 element in size will result
    in an `error`.
    &quot;&quot;&quot;
    if v.size() == _Size.fixext_1() then
      _write_type(b, _FormatName.fixext_1())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun fixext_2(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    fixext 2 stores an integer and a byte array whose length is 2 byte.

    Attempting to encode a `ByteSeq` that is not 2 element in size will result
    in an `error`.
    &quot;&quot;&quot;
    if v.size() == _Size.fixext_2() then
      _write_type(b, _FormatName.fixext_2())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun fixext_4(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    fixext 4 stores an integer and a byte array whose length is 4 byte.

    Attempting to encode a `ByteSeq` that is not 4 element in size will result
    in an `error`.
    &quot;&quot;&quot;
    if v.size() == _Size.fixext_4() then
      _write_type(b, _FormatName.fixext_4())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun fixext_8(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    fixext 8 stores an integer and a byte array whose length is 8 byte.

    Attempting to encode a `ByteSeq` that is not 8 element in size will result
    in an `error`.
    &quot;&quot;&quot;
    if v.size() == _Size.fixext_8() then
      _write_type(b, _FormatName.fixext_8())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun fixext_16(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    fixext 16 stores an integer and a byte array whose length is 16 byte.

    Attempting to encode a `ByteSeq` that is not 16 element in size will result
    in an `error`.
    &quot;&quot;&quot;
    if v.size() == _Size.fixext_16() then
      _write_type(b, _FormatName.fixext_16())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun ext_8(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    ext 8 stores an integer and a byte array whose length is
    upto (2^8)-1 bytes.

    Attempting to encode a `ByteSeq` that is larger than (2^8)-1 bytes in
    size will result in an `error`.
    &quot;&quot;&quot;
    if v.size() &lt;= U8.max_value().usize() then
      _write_type(b, _FormatName.ext_8())
      b.u8(v.size().u8())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun ext_16(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    ext 16 stores an integer and a byte array whose length is
    upto (2^16)-1 bytes.

    Attempting to encode a `ByteSeq` that is larger than (2^16)-1 bytes in
    size will result in an `error`.
    &quot;&quot;&quot;
    if v.size() &lt;= U16.max_value().usize() then
      _write_type(b, _FormatName.ext_16())
      b.u16_be(v.size().u16())
      b.u8(t)
      b.write(v)
    else
      error
    end

  fun ext_32(b: Writer, t: U8, v: ByteSeq) ? =&gt;
    &quot;&quot;&quot;
    Allows for the creation of user supplied extensions to the MessagePack
    format. User should provide not just the value `v` to be encoded, but a
    unique type identifier `t` as well.

    Type identifiers `0` to `127` are valid for user supplied types.
    MessagePack reserves -1 to -128 for future extension to add predefined
    types.

    ext 32 stores an integer and a byte array whose length is
    upto (2^32)-1 bytes.

    Attempting to encode a `ByteSeq` that is larger than (2^32)-1 bytes in
    size will result in an `error`.
    &quot;&quot;&quot;
    if v.size() &lt;= U32.max_value().usize() then
      _write_type(b, _FormatName.ext_32())
      b.u32_be(v.size().u32())
      b.u8(t)
      b.write(v)
    else
      error
    end

  //
  // timestamp format family
  //

  fun timestamp_32(b: Writer, sec: U32) =&gt;
    &quot;&quot;&quot;
    timestamp 32 stores the number of seconds that have elapsed since 1970-01-01
    00:00:00 UTC in a 32-bit unsigned integer.

    It can represent a timestamp in [1970-01-01 00:00:00 UTC, 2106-02-07
    06:28:16 UTC).

    Nanoseconds part is 0.
    &quot;&quot;&quot;
    _write_type(b, _FormatName.fixext_4())
    b.u8(-1)
    b.u32_be(sec)

  fun timestamp_64(b: Writer, sec: U64, nsec: U32) ? =&gt;
    &quot;&quot;&quot;
    timestamp 64 stores the number of seconds and nanoseconds that have elapsed
    since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers.

    It can represent a timestamp in [1970-01-01 00:00:00.000000000 UTC,
    2514-05-30 01:53:04.000000000 UTC).

    `nsec` must not be larger than 999999999. `sec` must not be larger than
    (2^34 - 1).
    &quot;&quot;&quot;
    if (nsec &lt;= _Limit.nsec()) and (sec &lt;= _Limit.sec_34()) then
      _write_type(b, _FormatName.fixext_8())
      b.u8(-1)
      b.u64_be((nsec.u64() &lt;&lt; 34) + sec)
    else
      error
    end

  fun timestamp_96(b: Writer, sec: I64, nsec: U32) ? =&gt;
    &quot;&quot;&quot;
    timestamp 96 stores the number of seconds and nanoseconds that have elapsed
    since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned
    integer.

    It can represent a timestamp in [-584554047284-02-23 16:59:44 UTC,
    584554051223-11-09 07:00:16.000000000 UTC).

    `nsec` must not be larger than 999999999.
    &quot;&quot;&quot;
    if nsec &lt;= _Limit.nsec() then
      _write_type(b, _FormatName.ext_8())
      b.u8(12)
      b.u8(-1)
      b.u32_be(nsec)
      b.i64_be(sec)
    else
      error
    end

  //
  // support methods
  //

  fun _write_type(b: Writer, t: U8) =&gt;
    b.u8(t)

  fun _write_fixed_value(b: Writer, v: U8) =&gt;
    b.u8(v)

  fun _write_byte_array_8(b: Writer, v: ByteSeq, t: U8) ? =&gt;
    if v.size() &lt;= U8.max_value().usize() then
      _write_type(b, t)
      b.u8(v.size().u8())
      b.write(v)
    else
      error
    end

  fun _write_byte_array_16(b: Writer, v: ByteSeq, t: U8) ? =&gt;
    if v.size() &lt;= U16.max_value().usize() then
      _write_type(b, t)
      b.u16_be(v.size().u16())
      b.write(v)
    else
      error
    end

  fun _write_byte_array_32(b: Writer, v: ByteSeq, t: U8) ? =&gt;
    if v.size() &lt;= U32.max_value().usize() then
      _write_type(b, t)
      b.u32_be(v.size().u32())
      b.write(v)
    else
      error
    end

</code></pre>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
    <script src="../../../assets/javascripts/application.cb37bb38.js"></script>
      
      <script>app.initialize({version:"1.2.3",url:{base:"../../.."}})</script>
      
    
    
      
    
  </body>
</html>